{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"django-readers A lightweight function-oriented toolkit for better organisation of business logic and efficient selection and projection of data in Django projects. Install from PyPI : pip install django-readers A word from our sponsor django-readers is developed and supported by DabApps , a UK-based web and mobile agency. We design and build bespoke software that helps our clients succeed. We \u2764\ufe0f Django and use it for all server-side code. And we're hiring ! What is django-readers? \u00b6 django-readers is both a small library and a collection of recommended patterns for structuring your code. It is intended to help with code that performs reads : querying your database and presenting the data to the user. It can be used with views that render HTML templates as well as Django REST framework API views, and indeed anywhere else in your project where data is retrieved from the database. It lets you: Query your database more efficiently, by specifying precisely which fields and relationships you need to load. It can help eliminate the N+1 queries problem . Create Django REST framework API endpoints using a declarative specification of their data shape, without needing to write serializer classes. Optionally, structure your business logic code following function-oriented idioms that may result in a more maintainable, testable codebase and helps prevent \"fat models\" turning into big balls of mud . django-readers is intended to feel like Django. You can use as much or as little of the library or the patterns as you like, and mix it in with an existing project. It doesn't attempt to hide away any parts of Django itself, and it introduces only a few straightforward concepts. Show me some code \u00b6 django-readers lets you write Django views like this: def author_list ( request ): spec = [ \"id\" , \"name\" , { \"book_set\" : [ \"id\" , \"title\" , \"publication_date\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Author . objects . all ()) return render ( request , \"author_list.html\" , { \"authors\" : [ project ( instance ) for instance in queryset ]}, ) And Django REST framework views like this: class AuthorListView ( SpecMixin , ListAPIView ): queryset = Author . objects . all () spec = [ \"id\" , \"name\" , { \"book_set\" : [ \"id\" , \"title\" , \"publication_date\" , ] }, ]","title":"Introduction"},{"location":"#what-is-django-readers","text":"django-readers is both a small library and a collection of recommended patterns for structuring your code. It is intended to help with code that performs reads : querying your database and presenting the data to the user. It can be used with views that render HTML templates as well as Django REST framework API views, and indeed anywhere else in your project where data is retrieved from the database. It lets you: Query your database more efficiently, by specifying precisely which fields and relationships you need to load. It can help eliminate the N+1 queries problem . Create Django REST framework API endpoints using a declarative specification of their data shape, without needing to write serializer classes. Optionally, structure your business logic code following function-oriented idioms that may result in a more maintainable, testable codebase and helps prevent \"fat models\" turning into big balls of mud . django-readers is intended to feel like Django. You can use as much or as little of the library or the patterns as you like, and mix it in with an existing project. It doesn't attempt to hide away any parts of Django itself, and it introduces only a few straightforward concepts.","title":"What is django-readers?"},{"location":"#show-me-some-code","text":"django-readers lets you write Django views like this: def author_list ( request ): spec = [ \"id\" , \"name\" , { \"book_set\" : [ \"id\" , \"title\" , \"publication_date\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Author . objects . all ()) return render ( request , \"author_list.html\" , { \"authors\" : [ project ( instance ) for instance in queryset ]}, ) And Django REST framework views like this: class AuthorListView ( SpecMixin , ListAPIView ): queryset = Author . objects . all () spec = [ \"id\" , \"name\" , { \"book_set\" : [ \"id\" , \"title\" , \"publication_date\" , ] }, ]","title":"Show me some code"},{"location":"cookbook/","text":"This section of the documentation is intended to give you real-world examples of how to achieve specific requirements with django-readers . It uses the same set of models (books, authors and publishers) introduced in the tutorial . In most cases, we just show the spec itself, and any custom reader functions. These specs can be used either inside a view or with the Django REST framework SpecMixin . Retrieve fields from a model instance \u00b6 spec = [ \"id\" , \"title\" , \"publication_date\" , ] Retrieve id of related model instance \u00b6 spec = [ \"publisher_id\" , ] Alias a field (change the output field name) \u00b6 spec = [ \"id\" , { \"date_published\" : \"publication_date\" }, ] Retrieve fields on related instance or instances \u00b6 spec = [ { \"publisher\" : [ \"id\" , \"name\" , ] }, { \"authors\" : [ \"id\" , \"name\" , ] }, ] Follow a reverse foreign key \u00b6 This spec would be applied to the Publisher model: spec = [ \"name\" , { \"book_set\" : [ \"id\" , \"title\" , ] }, ] Retrieve a list of the IDs of related objects \u00b6 spec = [ \"name\" , { \"book_set\" : pairs . pk_list ( \"book_set\" )}, ] Filter the set of related instances \u00b6 pairs.filter(args) is a shortcut for (qs.filter(args), projectors.noop) spec = [ \"name\" , { \"book_set\" : [ pairs . filter ( publication_date__year = 2022 ), \"id\" , \"title\" , ] }, ] Alias a relationship \u00b6 To alias a relationship, nest the relationship spec inside another dictionary: spec = [ \"name\" , { \"books_2022\" : { \"book_set\" : [ pairs . filter ( publication_date__year = 2022 ), \"id\" , \"title\" , ] } }, ] Alias a relationship with a custom to_attr \u00b6 The above example uses the default name ( book_set ) for the relationship when the related objects are prefetched. If you wish to load the same relationship multiple times with different filters, this won't work. To provide a to_attr for the relationship, drop down to the specs.relationship function: from django_readers import specs spec = [ \"name\" , specs . relationship ( \"book_set\" , [ pairs . filter ( publication_date__year = 2022 ), \"id\" , \"title\" , ], to_attr = \"books_2022\" , ) ] Apply arbitrary queryset operations \u00b6 spec = [ \"name\" , { \"book_set\" : [ pairs . filter ( publication_date__year = 2022 ), ( qs . distinct (), projectors . noop ), \"id\" , \"title\" , ] }, ] Retrieve a count of related models \u00b6 spec = [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ] Derive a value via an arbitrary annotation \u00b6 published_in_2022 = ( qs . annotate ( published_in_2022 = Case ( When ( publication_date__year = 2022 , then = True ), default = False , ) ), producers . attr ( \"published_in_2022\" ), ) spec = [ \"title\" , { \"published_in_2022\" : published_in_2022 }, ] Retrieve a value from a model property that requires a model field to be loaded \u00b6 class Book ( models . Model ): ... @property def published_this_year ( self ): return self . publication_date . year == date . today () . year spec = [ \"title\" , { \"published_this_year\" : ( qs . include_fields ( \"publication_date\" ), producers . attr ( \"published_this_year\" ), ) }, ] Call a method on a model that requires a model field to be loaded \u00b6 class Book ( models . Model ): ... def published_in_year ( self , year ): return self . publication_date . year == year spec = [ \"title\" , { \"published_in_2020\" : ( qs . include_fields ( \"publication_date\" ), producers . method ( \"published_in_year\" , 2020 ), ) }, ] Parameterise a pair with a higher-order pair function \u00b6 def email_domain_is ( domain ): prepare = qs . include_fields ( \"email\" ) def produce ( author ): return author . email . endswith ( domain ) return prepare , produce spec = [ \"id\" , \"name\" , { \"works_for_google\" : email_domain_is ( \"google.com\" )}, { \"works_for_apple\" : email_domain_is ( \"apple.com\" )}, ] Use select_related instead of prefetch_related \u00b6 We use the specs.relationship function but explicitly discard its queryset function and substitute our own. Note that this has major limitations: because the relationship is not represented by a queryset internally, the spec cannot be nested any further and no custom pairs can be used. Only do this if you're sure you know what you're doing. spec = [ \"id\" , \"title\" , { \"publisher\" : ( qs . select_related_fields ( \"publisher__name\" ), pairs . discard_queryset_function ( specs . relationship ( \"publisher\" , [ \"name\" ]), ), ) }, ] Specify output fields for Django REST framework introspection \u00b6 The Django REST framework layer supports generation of serializer classes based on a spec, for the purpose of introspection and schema generation. For custom behaviour like pairs and higher-order functions, the output field type must be explicitly specified. Below is an example covering a couple of use cases. See the docs on serializer and schema generation for full details. from django_readers.rest_framework import out , serializer_class_for_view , SpecMixin from rest_framework.views import RetrieveAPIView from rest_framework import serializers class SpecSchema ( AutoSchema ): def get_serializer ( self , path , method ): return serializer_class_for_view ( self . view )() @out ( serializers . BooleanField ()) def request_user_is_author ( request ): def produce ( instance ): return instance . author . email == request . user . email return ( qs . auto_prefetch_relationship ( \"author\" , prepare_related_queryset = qs . include_fields ( \"email\" ), ), produce , ) class BookDetailView ( SpecMixin , RetrieveAPIView ): schema = SpecSchema () queryset = Book . objects . all () spec = [ \"id\" , \"title\" , { \"request_user_is_author\" : request_user_is_author }, { \"format\" : pairs . field_display ( \"format\" ) >> out ( serializers . CharField ())}, ]","title":"Cookbook"},{"location":"cookbook/#retrieve-fields-from-a-model-instance","text":"spec = [ \"id\" , \"title\" , \"publication_date\" , ]","title":"Retrieve fields from a model instance"},{"location":"cookbook/#retrieve-id-of-related-model-instance","text":"spec = [ \"publisher_id\" , ]","title":"Retrieve id of related model instance"},{"location":"cookbook/#alias-a-field-change-the-output-field-name","text":"spec = [ \"id\" , { \"date_published\" : \"publication_date\" }, ]","title":"Alias a field (change the output field name)"},{"location":"cookbook/#retrieve-fields-on-related-instance-or-instances","text":"spec = [ { \"publisher\" : [ \"id\" , \"name\" , ] }, { \"authors\" : [ \"id\" , \"name\" , ] }, ]","title":"Retrieve fields on related instance or instances"},{"location":"cookbook/#follow-a-reverse-foreign-key","text":"This spec would be applied to the Publisher model: spec = [ \"name\" , { \"book_set\" : [ \"id\" , \"title\" , ] }, ]","title":"Follow a reverse foreign key"},{"location":"cookbook/#retrieve-a-list-of-the-ids-of-related-objects","text":"spec = [ \"name\" , { \"book_set\" : pairs . pk_list ( \"book_set\" )}, ]","title":"Retrieve a list of the IDs of related objects"},{"location":"cookbook/#filter-the-set-of-related-instances","text":"pairs.filter(args) is a shortcut for (qs.filter(args), projectors.noop) spec = [ \"name\" , { \"book_set\" : [ pairs . filter ( publication_date__year = 2022 ), \"id\" , \"title\" , ] }, ]","title":"Filter the set of related instances"},{"location":"cookbook/#alias-a-relationship","text":"To alias a relationship, nest the relationship spec inside another dictionary: spec = [ \"name\" , { \"books_2022\" : { \"book_set\" : [ pairs . filter ( publication_date__year = 2022 ), \"id\" , \"title\" , ] } }, ]","title":"Alias a relationship"},{"location":"cookbook/#alias-a-relationship-with-a-custom-to_attr","text":"The above example uses the default name ( book_set ) for the relationship when the related objects are prefetched. If you wish to load the same relationship multiple times with different filters, this won't work. To provide a to_attr for the relationship, drop down to the specs.relationship function: from django_readers import specs spec = [ \"name\" , specs . relationship ( \"book_set\" , [ pairs . filter ( publication_date__year = 2022 ), \"id\" , \"title\" , ], to_attr = \"books_2022\" , ) ]","title":"Alias a relationship with a custom to_attr"},{"location":"cookbook/#apply-arbitrary-queryset-operations","text":"spec = [ \"name\" , { \"book_set\" : [ pairs . filter ( publication_date__year = 2022 ), ( qs . distinct (), projectors . noop ), \"id\" , \"title\" , ] }, ]","title":"Apply arbitrary queryset operations"},{"location":"cookbook/#retrieve-a-count-of-related-models","text":"spec = [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ]","title":"Retrieve a count of related models"},{"location":"cookbook/#derive-a-value-via-an-arbitrary-annotation","text":"published_in_2022 = ( qs . annotate ( published_in_2022 = Case ( When ( publication_date__year = 2022 , then = True ), default = False , ) ), producers . attr ( \"published_in_2022\" ), ) spec = [ \"title\" , { \"published_in_2022\" : published_in_2022 }, ]","title":"Derive a value via an arbitrary annotation"},{"location":"cookbook/#retrieve-a-value-from-a-model-property-that-requires-a-model-field-to-be-loaded","text":"class Book ( models . Model ): ... @property def published_this_year ( self ): return self . publication_date . year == date . today () . year spec = [ \"title\" , { \"published_this_year\" : ( qs . include_fields ( \"publication_date\" ), producers . attr ( \"published_this_year\" ), ) }, ]","title":"Retrieve a value from a model property that requires a model field to be loaded"},{"location":"cookbook/#call-a-method-on-a-model-that-requires-a-model-field-to-be-loaded","text":"class Book ( models . Model ): ... def published_in_year ( self , year ): return self . publication_date . year == year spec = [ \"title\" , { \"published_in_2020\" : ( qs . include_fields ( \"publication_date\" ), producers . method ( \"published_in_year\" , 2020 ), ) }, ]","title":"Call a method on a model that requires a model field to be loaded"},{"location":"cookbook/#parameterise-a-pair-with-a-higher-order-pair-function","text":"def email_domain_is ( domain ): prepare = qs . include_fields ( \"email\" ) def produce ( author ): return author . email . endswith ( domain ) return prepare , produce spec = [ \"id\" , \"name\" , { \"works_for_google\" : email_domain_is ( \"google.com\" )}, { \"works_for_apple\" : email_domain_is ( \"apple.com\" )}, ]","title":"Parameterise a pair with a higher-order pair function"},{"location":"cookbook/#use-select_related-instead-of-prefetch_related","text":"We use the specs.relationship function but explicitly discard its queryset function and substitute our own. Note that this has major limitations: because the relationship is not represented by a queryset internally, the spec cannot be nested any further and no custom pairs can be used. Only do this if you're sure you know what you're doing. spec = [ \"id\" , \"title\" , { \"publisher\" : ( qs . select_related_fields ( \"publisher__name\" ), pairs . discard_queryset_function ( specs . relationship ( \"publisher\" , [ \"name\" ]), ), ) }, ]","title":"Use select_related instead of prefetch_related"},{"location":"cookbook/#specify-output-fields-for-django-rest-framework-introspection","text":"The Django REST framework layer supports generation of serializer classes based on a spec, for the purpose of introspection and schema generation. For custom behaviour like pairs and higher-order functions, the output field type must be explicitly specified. Below is an example covering a couple of use cases. See the docs on serializer and schema generation for full details. from django_readers.rest_framework import out , serializer_class_for_view , SpecMixin from rest_framework.views import RetrieveAPIView from rest_framework import serializers class SpecSchema ( AutoSchema ): def get_serializer ( self , path , method ): return serializer_class_for_view ( self . view )() @out ( serializers . BooleanField ()) def request_user_is_author ( request ): def produce ( instance ): return instance . author . email == request . user . email return ( qs . auto_prefetch_relationship ( \"author\" , prepare_related_queryset = qs . include_fields ( \"email\" ), ), produce , ) class BookDetailView ( SpecMixin , RetrieveAPIView ): schema = SpecSchema () queryset = Book . objects . all () spec = [ \"id\" , \"title\" , { \"request_user_is_author\" : request_user_is_author }, { \"format\" : pairs . field_display ( \"format\" ) >> out ( serializers . CharField ())}, ]","title":"Specify output fields for Django REST framework introspection"},{"location":"explanation/","text":"django-readers provides a set of tools to help with the parts of your business logic that are responsible for reads from the database: selecting and transforming data before presenting it to clients. It can be used with views that render Django templates as well as Django REST framework views. The functionality that django-readers provides is deliberately straightforward and interoperable with existing Django libraries, patterns and practices. You can choose to use just the parts of django-readers that appeal to you and make sense in your project. A django-readers \"spec\" precisely specifies the data that your view depends on (which particular fields from which related models). Only this data will be fetched from the database, in the most efficient way possible. This is intended to avoid the N+1 queries problem and can dramatically improve the performance of your application. However, django-readers is more than just this. It is also intended to suggest patterns which help with organising business logic in a Django codebase, following a function-oriented style. It introduces a few simple concepts, and provides some tools to assemble them together into a working application. It can easily be combined with existing patterns and libraries. queryset preparation functions replace custom queryset methods and encapsulate data selection: filtering, annotation etc. They can be composed to express complex selection logic. producer and projector functions replace model methods and encapsulate business logic for transforming and presenting data. They can be combined to form lightweight business objects (dictionaries) that are the right shape for the code that consumes them. reader pairs combine queryset functions and producers (or projectors), expressing the dependencies between them. a high-level spec provides a concise way to express exactly which data should be selected and projected at the point of use. Motivation \u00b6 Django common practices encourage a \"fat models\" approach. Most of the business logic of the application goes in the model layer (on the models themselves, or on custom managers or querysets). Experience has suggested that this is often a bad idea for several reasons: First, it goes against the Single Responsibility Principle . Models are already responsible for mapping between your database tables and your application code and back again. This mapping is a highly complex task, and that's quite enough for one set of classes to be responsible for. Second, it is bad for code organisation, particularly in larger projects. Your models.py becomes a trash pile onto which all business logic is dumped. Models and querysets grow to thousands of lines of code. The API surface area for each model becomes huge, and this entire surface is available to any part of your application that imports the model. Third and worst, often model methods themselves perform queries against other models. This is a disaster for application performance, leading to inefficient query patterns that can be very difficult to fix. When they are fixed (through judicious use of select_related and prefetch_related on the queryset), the model methods become tightly coupled to the precise way that the query is built, resulting in unpredictable and brittle code. django-readers encourages you to structure your code around plain functions rather than methods on classes. You can put these functions wherever you like in your codebase. Complex business logic is built by composing and combining these functions. Note YAGNI, \"You Aren't Gonna Need It\", it's a well-understood mantra in software development. It means that you should only make changes to your software (including adding abstraction and generalising code structures) when you are sure that you absolutely need them, and not before. Related to this is the famous quote from Donald Knuth: \"premature optimization is the root of all evil\". This suggests that usually performance concerns fall under YAGNI: you shouldn't spend time making code fast until its slowness becomes a real problem for users. As a counterpoint to this advice, Simon Willison coined the phrase PAGNI , \"Probably Are Gonna Need It\". PAGNI applies in situations \"when the cost of adding something later is so dramatically expensive compared with the cost of adding it early on that it\u2019s worth taking the risk [...] when you know from experience that an initial investment will pay off many times over.\" django-readers (and its sister project django-zen-queries ) were built partly as a result of a strong belief (gained through many years of experience) that understanding and controlling your application's database querying behaviour firmly falls into the PAGNI category. This is particularly true of applications that you know are going to be complex: any code abstraction patterns you decide to follow in order to manage the complexity must take into account query patterns or they are highly likely to cause terrible performance problems. This is the heart of the object-relational impedance mismatch . Features and concepts \u00b6 django-readers is organised in three layers of \"reader functions\" . At the highest level of abstraction is django_readers.specs (the top layer), which depends on django_readers.pairs (the middle layer), which depends on django_readers.producers , django_readers.projectors and django_readers.qs (the bottom layer). These layers can be intermingled in a real-world application. To expain each layer, it makes most sense to start at the bottom and work upwards. Queryset preparation functions \u00b6 A queryset preparation function is a function that accepts a queryset as its single argument, and returns a new queryset with some modifications applied. These functions are used to encapsulate database query logic that would traditionally live in a custom queryset method. If you were writing one of these yourself, it might look like this: def prepare ( queryset ): return queryset . filter ( name = \"shakespeare\" ) However, you don't usually need to write your own queryset functions: django-readers provides a library of functions under django_readers.qs which mirror all the default methods on the base QuerySet that return a new queryset, as well as some extra utility functions. Queryset functions can be combined with the qs.pipe function (named following standard functional programming parlance). qs.pipe returns a new queryset function that calls each function in its argument list in turn, passing the return value of the first as the argument of the second, and so on. It literally \"pipes\" your queryset through its list of functions. from django_readers import qs recent_books_with_prefetched_authors = qs . pipe ( qs . filter ( publication_date__year = 2020 ), qs . prefetch_related ( \"authors\" ), qs . order_by ( \"name\" ), ) queryset = recent_books_with_prefetched_authors ( Book . objects . all ()) Producers and projectors \u00b6 A producer is a function that accepts a model instance as its single argument, and returns a value representing a subset or transformation of the instance data. Business logic that would traditionally go in model methods should instead go in producers. from datetime import datetime def produce_age ( instance ): return datetime . now () . year - instance . birth_year author = Author ( name = \"Some Author\" , birth_year = 1984 ) print ( produce_age ( author )) # 37 The simplest producer is one that returns the value of an object attribute. django-readers provides a function to create producers that do this: from django_readers import producers author = Author ( name = \"Some Author\" ) produce_name = producers . attr ( \"name\" ) print ( produce_name ( author )) # 'Some Author' Producers return a value, but in order to convert a model instance into a lightweight business object (a dictionary) suitable for passing around your project, this value must be combined with a name. This is the role of a projector . A projector function takes a model instance and returns a dictionary mapping keys to the values returned by producer functions. These functions \"project\" your data layer into your application's business logic domain. Think of the dictionary returned by a projector (the \"projection\") as the simplest possible domain object. Generally speaking, it's not necessary to write your own projector functions. You can instead wrap a producer function with projectors.producer_to_projector from datetime import datetime from django_readers import projectors def produce_age ( instance ): return datetime . now () . year - instance . birth_year project_age = projectors . producer_to_projector ( \"age\" , produce_age ) author = Author ( name = \"Some Author\" , birth_year = 1984 ) print ( project_age ( author )) # {'age': 37} Like queryset functions, projectors are intended to be composable : multiple simple projector functions can be combined into a more complex projector function that returns a dictionary containing the keys and values from all of its child projectors. This is done using the projectors.combine function: from django_readers import producers , projectors project = projectors . combine ( projectors . producer_to_projector ( \"name\" , producers . attr ( \"name\" )), projectors . producer_to_projector ( \"age\" , produce_age ), ) print ( project ( author )) # {'name': 'Some Author', 'age': 37} This composition generally happens at the place in your codebase where the domain model is actually being used (in a view, say). The projection will therefore contain precisely the keys needed by that view. This solves the problem of models becoming vast ever-growing flat namespaces containing all the functionality needed by all parts of your application. Related objects can also be produced using the producers.relationship function, resulting in a nested projection: project = projectors . combine ( projectors . producer_to_projector ( \"name\" , producers . attr ( \"name\" )), projectors . producer_to_projector ( \"age\" , produce_age ), projectors . producer_to_projector ( \"book_set\" , producers . relationship ( \"book_set\" , projectors . combine ( projectors . producer_to_projector ( \"title\" , producers . attr ( \"title\" ), ), projectors . producer_to_projector ( \"publication_date\" , producers . attr ( \"publication_date\" ), ), ), ), ), ) print ( project ( author )) # { # 'name': 'Some Author', # 'age': 37, # 'book_set': [ # {'title': 'Some Book', 'publication_date': 2019} # ] # } Note above that the second argument to producers.relationship is a projector function to project each related object. Pairs \u00b6 prepare and produce (and therefore also project ) functions are intimately connected, with the produce / project functions usually depending on fields, annotations or relationships loaded by the prepare function. For this reason, django-readers expects these functions to live together in two-tuples: (prepare, produce) (a \"producer pair\") and (prepare, project) (a \"projector pair\"). Remember that the difference between produce and project is that the former returns a single value, whereas the latter returns a dictionary binding one or more names (keys) to one or more values. In the example used above, the produce_age producer depends on the birth_year field: age = ( qs . include_fields ( \"birth_year\" ), produce_age ) django-readers includes some useful functions that create pairs . These attempt to generate the most efficient queries they can, which means loading only those database fields required to produce the value or values: from django_readers import pairs prepare , produce = pairs . field ( \"name\" ) queryset = prepare ( Author . objects . all ()) print ( queryset . query ) # SELECT \"author\".\"id\", \"author\".\"name\" FROM \"author\" print ( produce ( queryset . first ())) # 'Some Author' When composing multiple pairs together, it is again necessary to wrap the producer to convert it to a projector, thus forming (prepare, project) pairs. This can be done with the pairs.producer_to_projector function: prepare , project = pairs . combine ( pairs . producer_to_projector ( \"name\" , pairs . field ( \"name\" )), pairs . producer_to_projector ( \"birth_year\" , pairs . field ( \"birth_year\" )), ) Relationships can automatically be loaded and projected, too: prepare , project = pairs . combine ( pairs . producer_to_projector ( \"name\" , pairs . field ( \"name\" )), pairs . producer_to_projector ( \"age\" , age ), pairs . producer_to_projector ( \"book_set\" , pairs . relationship ( \"book_set\" , pairs . combine ( pairs . producer_to_projector ( \"title\" , pairs . field ( \"title\" )), pairs . producer_to_projector ( \"publication_date\" , pairs . field ( \"publication_date\" ) ), ), ), ), ) Again, only the precise fields that are needed are loaded from the database. All relationship functions take an optional to_attr argument which is passed to the underlying Prefetch object. Note that django-readers always uses prefetch_related to load relationships, even in circumstances where select_related would usually be used (i.e. ForeignKey and OneToOneField ), resulting in one query per relationship. This approach allows the code to be \"fractal\": the tree of (prepare, project) pairs can be recursively applied to the tree of related querysets. It is possible to use select_related but this must be done manually . Specs \u00b6 Manually assembling trees of pairs as seen above may seem long-winded. The specs module provides a layer of syntactic sugar that makes it much easier. This layer is the real magic of django-readers : a straightforward way of specifying the shape of your data in order to efficiently select and project a complex tree of related objects. The resulting nested dictionary structure may be returned from a view as a JSON response (assuming all your producers return JSON-serializable values), or included in a template context in place of a queryset or model instance. A spec is a list. Under the hood, the specs module is a very lightweight wrapper on top of pairs . Each item in the list undergoes a simple transformation to replace it with a pair function. See the reference documentation for specs for details. The example from the last section may be written as the following spec: from django_readers import specs spec = [ \"name\" , { \"age\" : age }, { \"book_set\" : [ \"title\" , \"publication_date\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Author . objects . all ()) result = [ project ( instance ) for instance in queryset ] Note The structure of this specification is heavily inspired by django-rest-framework-serialization-spec , minus the concept of \"plugins\", which are replaced with directly including (prepare, produce) pairs in the spec. It should be trivial to convert or \"adapt\" a serialization-spec plugin into a suitable django-readers pair. Where should this code go? \u00b6 We recommend that your custom functions go in a file called readers.py inside your Django apps. Specs should be declared at the point they are used, usually in your views.py . What about other types of business logic? \u00b6 You'll notice that django-readers is focused on reads : business logic which selects some data from the database and/or transforms it in such a way that it can be displayed to a user. What about other common types of business logic that involve accepting input from users and processing it? django-readers doesn't provide any code to help with this, but we encourage you to follow the same function-oriented philosophy. Structure your codebase around functions which take model instances and encapsulate these sorts of write actions. You might choose to call them action functions and place them in a file called actions.py . The other common task needed is data validation. We'd suggest Django forms and/or Django REST framework serializers are perfectly adequate here. Is django-readers a \"service layer\"? \u00b6 Not really, although it does solve some of the same problems. It suggests alternative (and, we think, beneficial) ways to structure your business logic without attempting to hide or abstract away the underlying Django concepts, and so should be easily understandable by any experienced Django developer. You can easily \"mix and match\" django-readers concepts into an existing application. If you are someone who feels more comfortable thinking in terms of established Design Patterns, you may consider the dictionaries returned from projector functions as simple Data Transfer Objects , and the idea of dividing read and write logic into readers and actions as a version of CQRS . Is django-readers a serialization or data conversion library? \u00b6 Not really, although again it does solve some of the same problems. django-readers is often compared to projects like attrs / cattrs and pydantic . However, django-readers is focused on the shape of the data and how to extract it from the database (via the Django ORM) efficiently, rather than converting and validating the types. It eschews a class-oriented style in favour of plain, composable functions operating on plain data structures like dictionaries, and deliberately avoids static type annotations. If your intention is to render your data to JSON, we recommend you use django-readers to project the model field values, and then lean on Django or Django REST framework's built-in rich encoders for converting types like datetime and UUID to JSON-friendly strings.","title":"Explanation"},{"location":"explanation/#motivation","text":"Django common practices encourage a \"fat models\" approach. Most of the business logic of the application goes in the model layer (on the models themselves, or on custom managers or querysets). Experience has suggested that this is often a bad idea for several reasons: First, it goes against the Single Responsibility Principle . Models are already responsible for mapping between your database tables and your application code and back again. This mapping is a highly complex task, and that's quite enough for one set of classes to be responsible for. Second, it is bad for code organisation, particularly in larger projects. Your models.py becomes a trash pile onto which all business logic is dumped. Models and querysets grow to thousands of lines of code. The API surface area for each model becomes huge, and this entire surface is available to any part of your application that imports the model. Third and worst, often model methods themselves perform queries against other models. This is a disaster for application performance, leading to inefficient query patterns that can be very difficult to fix. When they are fixed (through judicious use of select_related and prefetch_related on the queryset), the model methods become tightly coupled to the precise way that the query is built, resulting in unpredictable and brittle code. django-readers encourages you to structure your code around plain functions rather than methods on classes. You can put these functions wherever you like in your codebase. Complex business logic is built by composing and combining these functions. Note YAGNI, \"You Aren't Gonna Need It\", it's a well-understood mantra in software development. It means that you should only make changes to your software (including adding abstraction and generalising code structures) when you are sure that you absolutely need them, and not before. Related to this is the famous quote from Donald Knuth: \"premature optimization is the root of all evil\". This suggests that usually performance concerns fall under YAGNI: you shouldn't spend time making code fast until its slowness becomes a real problem for users. As a counterpoint to this advice, Simon Willison coined the phrase PAGNI , \"Probably Are Gonna Need It\". PAGNI applies in situations \"when the cost of adding something later is so dramatically expensive compared with the cost of adding it early on that it\u2019s worth taking the risk [...] when you know from experience that an initial investment will pay off many times over.\" django-readers (and its sister project django-zen-queries ) were built partly as a result of a strong belief (gained through many years of experience) that understanding and controlling your application's database querying behaviour firmly falls into the PAGNI category. This is particularly true of applications that you know are going to be complex: any code abstraction patterns you decide to follow in order to manage the complexity must take into account query patterns or they are highly likely to cause terrible performance problems. This is the heart of the object-relational impedance mismatch .","title":"Motivation"},{"location":"explanation/#features-and-concepts","text":"django-readers is organised in three layers of \"reader functions\" . At the highest level of abstraction is django_readers.specs (the top layer), which depends on django_readers.pairs (the middle layer), which depends on django_readers.producers , django_readers.projectors and django_readers.qs (the bottom layer). These layers can be intermingled in a real-world application. To expain each layer, it makes most sense to start at the bottom and work upwards.","title":"Features and concepts"},{"location":"explanation/#queryset-preparation-functions","text":"A queryset preparation function is a function that accepts a queryset as its single argument, and returns a new queryset with some modifications applied. These functions are used to encapsulate database query logic that would traditionally live in a custom queryset method. If you were writing one of these yourself, it might look like this: def prepare ( queryset ): return queryset . filter ( name = \"shakespeare\" ) However, you don't usually need to write your own queryset functions: django-readers provides a library of functions under django_readers.qs which mirror all the default methods on the base QuerySet that return a new queryset, as well as some extra utility functions. Queryset functions can be combined with the qs.pipe function (named following standard functional programming parlance). qs.pipe returns a new queryset function that calls each function in its argument list in turn, passing the return value of the first as the argument of the second, and so on. It literally \"pipes\" your queryset through its list of functions. from django_readers import qs recent_books_with_prefetched_authors = qs . pipe ( qs . filter ( publication_date__year = 2020 ), qs . prefetch_related ( \"authors\" ), qs . order_by ( \"name\" ), ) queryset = recent_books_with_prefetched_authors ( Book . objects . all ())","title":"Queryset preparation functions"},{"location":"explanation/#producers-and-projectors","text":"A producer is a function that accepts a model instance as its single argument, and returns a value representing a subset or transformation of the instance data. Business logic that would traditionally go in model methods should instead go in producers. from datetime import datetime def produce_age ( instance ): return datetime . now () . year - instance . birth_year author = Author ( name = \"Some Author\" , birth_year = 1984 ) print ( produce_age ( author )) # 37 The simplest producer is one that returns the value of an object attribute. django-readers provides a function to create producers that do this: from django_readers import producers author = Author ( name = \"Some Author\" ) produce_name = producers . attr ( \"name\" ) print ( produce_name ( author )) # 'Some Author' Producers return a value, but in order to convert a model instance into a lightweight business object (a dictionary) suitable for passing around your project, this value must be combined with a name. This is the role of a projector . A projector function takes a model instance and returns a dictionary mapping keys to the values returned by producer functions. These functions \"project\" your data layer into your application's business logic domain. Think of the dictionary returned by a projector (the \"projection\") as the simplest possible domain object. Generally speaking, it's not necessary to write your own projector functions. You can instead wrap a producer function with projectors.producer_to_projector from datetime import datetime from django_readers import projectors def produce_age ( instance ): return datetime . now () . year - instance . birth_year project_age = projectors . producer_to_projector ( \"age\" , produce_age ) author = Author ( name = \"Some Author\" , birth_year = 1984 ) print ( project_age ( author )) # {'age': 37} Like queryset functions, projectors are intended to be composable : multiple simple projector functions can be combined into a more complex projector function that returns a dictionary containing the keys and values from all of its child projectors. This is done using the projectors.combine function: from django_readers import producers , projectors project = projectors . combine ( projectors . producer_to_projector ( \"name\" , producers . attr ( \"name\" )), projectors . producer_to_projector ( \"age\" , produce_age ), ) print ( project ( author )) # {'name': 'Some Author', 'age': 37} This composition generally happens at the place in your codebase where the domain model is actually being used (in a view, say). The projection will therefore contain precisely the keys needed by that view. This solves the problem of models becoming vast ever-growing flat namespaces containing all the functionality needed by all parts of your application. Related objects can also be produced using the producers.relationship function, resulting in a nested projection: project = projectors . combine ( projectors . producer_to_projector ( \"name\" , producers . attr ( \"name\" )), projectors . producer_to_projector ( \"age\" , produce_age ), projectors . producer_to_projector ( \"book_set\" , producers . relationship ( \"book_set\" , projectors . combine ( projectors . producer_to_projector ( \"title\" , producers . attr ( \"title\" ), ), projectors . producer_to_projector ( \"publication_date\" , producers . attr ( \"publication_date\" ), ), ), ), ), ) print ( project ( author )) # { # 'name': 'Some Author', # 'age': 37, # 'book_set': [ # {'title': 'Some Book', 'publication_date': 2019} # ] # } Note above that the second argument to producers.relationship is a projector function to project each related object.","title":"Producers and projectors"},{"location":"explanation/#pairs","text":"prepare and produce (and therefore also project ) functions are intimately connected, with the produce / project functions usually depending on fields, annotations or relationships loaded by the prepare function. For this reason, django-readers expects these functions to live together in two-tuples: (prepare, produce) (a \"producer pair\") and (prepare, project) (a \"projector pair\"). Remember that the difference between produce and project is that the former returns a single value, whereas the latter returns a dictionary binding one or more names (keys) to one or more values. In the example used above, the produce_age producer depends on the birth_year field: age = ( qs . include_fields ( \"birth_year\" ), produce_age ) django-readers includes some useful functions that create pairs . These attempt to generate the most efficient queries they can, which means loading only those database fields required to produce the value or values: from django_readers import pairs prepare , produce = pairs . field ( \"name\" ) queryset = prepare ( Author . objects . all ()) print ( queryset . query ) # SELECT \"author\".\"id\", \"author\".\"name\" FROM \"author\" print ( produce ( queryset . first ())) # 'Some Author' When composing multiple pairs together, it is again necessary to wrap the producer to convert it to a projector, thus forming (prepare, project) pairs. This can be done with the pairs.producer_to_projector function: prepare , project = pairs . combine ( pairs . producer_to_projector ( \"name\" , pairs . field ( \"name\" )), pairs . producer_to_projector ( \"birth_year\" , pairs . field ( \"birth_year\" )), ) Relationships can automatically be loaded and projected, too: prepare , project = pairs . combine ( pairs . producer_to_projector ( \"name\" , pairs . field ( \"name\" )), pairs . producer_to_projector ( \"age\" , age ), pairs . producer_to_projector ( \"book_set\" , pairs . relationship ( \"book_set\" , pairs . combine ( pairs . producer_to_projector ( \"title\" , pairs . field ( \"title\" )), pairs . producer_to_projector ( \"publication_date\" , pairs . field ( \"publication_date\" ) ), ), ), ), ) Again, only the precise fields that are needed are loaded from the database. All relationship functions take an optional to_attr argument which is passed to the underlying Prefetch object. Note that django-readers always uses prefetch_related to load relationships, even in circumstances where select_related would usually be used (i.e. ForeignKey and OneToOneField ), resulting in one query per relationship. This approach allows the code to be \"fractal\": the tree of (prepare, project) pairs can be recursively applied to the tree of related querysets. It is possible to use select_related but this must be done manually .","title":"Pairs"},{"location":"explanation/#specs","text":"Manually assembling trees of pairs as seen above may seem long-winded. The specs module provides a layer of syntactic sugar that makes it much easier. This layer is the real magic of django-readers : a straightforward way of specifying the shape of your data in order to efficiently select and project a complex tree of related objects. The resulting nested dictionary structure may be returned from a view as a JSON response (assuming all your producers return JSON-serializable values), or included in a template context in place of a queryset or model instance. A spec is a list. Under the hood, the specs module is a very lightweight wrapper on top of pairs . Each item in the list undergoes a simple transformation to replace it with a pair function. See the reference documentation for specs for details. The example from the last section may be written as the following spec: from django_readers import specs spec = [ \"name\" , { \"age\" : age }, { \"book_set\" : [ \"title\" , \"publication_date\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Author . objects . all ()) result = [ project ( instance ) for instance in queryset ] Note The structure of this specification is heavily inspired by django-rest-framework-serialization-spec , minus the concept of \"plugins\", which are replaced with directly including (prepare, produce) pairs in the spec. It should be trivial to convert or \"adapt\" a serialization-spec plugin into a suitable django-readers pair.","title":"Specs"},{"location":"explanation/#where-should-this-code-go","text":"We recommend that your custom functions go in a file called readers.py inside your Django apps. Specs should be declared at the point they are used, usually in your views.py .","title":"Where should this code go?"},{"location":"explanation/#what-about-other-types-of-business-logic","text":"You'll notice that django-readers is focused on reads : business logic which selects some data from the database and/or transforms it in such a way that it can be displayed to a user. What about other common types of business logic that involve accepting input from users and processing it? django-readers doesn't provide any code to help with this, but we encourage you to follow the same function-oriented philosophy. Structure your codebase around functions which take model instances and encapsulate these sorts of write actions. You might choose to call them action functions and place them in a file called actions.py . The other common task needed is data validation. We'd suggest Django forms and/or Django REST framework serializers are perfectly adequate here.","title":"What about other types of business logic?"},{"location":"explanation/#is-django-readers-a-service-layer","text":"Not really, although it does solve some of the same problems. It suggests alternative (and, we think, beneficial) ways to structure your business logic without attempting to hide or abstract away the underlying Django concepts, and so should be easily understandable by any experienced Django developer. You can easily \"mix and match\" django-readers concepts into an existing application. If you are someone who feels more comfortable thinking in terms of established Design Patterns, you may consider the dictionaries returned from projector functions as simple Data Transfer Objects , and the idea of dividing read and write logic into readers and actions as a version of CQRS .","title":"Is django-readers a \"service layer\"?"},{"location":"explanation/#is-django-readers-a-serialization-or-data-conversion-library","text":"Not really, although again it does solve some of the same problems. django-readers is often compared to projects like attrs / cattrs and pydantic . However, django-readers is focused on the shape of the data and how to extract it from the database (via the Django ORM) efficiently, rather than converting and validating the types. It eschews a class-oriented style in favour of plain, composable functions operating on plain data structures like dictionaries, and deliberately avoids static type annotations. If your intention is to render your data to JSON, we recommend you use django-readers to project the model field values, and then lean on Django or Django REST framework's built-in rich encoders for converting types like datetime and UUID to JSON-friendly strings.","title":"Is django-readers a serialization or data conversion library?"},{"location":"tutorial/","text":"Installing django-readers \u00b6 Install from PyPI : pip install django-readers Prerequisites \u00b6 This tutorial assumes you understand the basics of Django (models, views, templates etc). Make sure you've been through the Django tutorial first. The section on Django REST framework assumes that you've read and understood the docs . Example models \u00b6 For the purposes of this tutorial, we're going to use a set of models representing books , authors and publishers . A book has exactly one publisher, but can have many authors. Here are the Django models we're using: class Publisher ( models . Model ): name = models . CharField ( max_length = 100 ) address = models . TextField () class Author ( models . Model ): name = models . CharField ( max_length = 100 ) email = models . EmailField () class Book ( models . Model ): title = models . CharField ( max_length = 100 ) authors = models . ManyToManyField ( Author ) publisher = models . ForeignKey ( Publisher ) publication_date = models . DateField () We're going to go through a step-by-step set of requirements from an imaginary client who has asked you to build a simple book listing application. We're going to assume the Django project itself has already been set up, and focus on a single view and a single template. Requirement 1: a list of book titles (without django-readers ) \u00b6 First, the client wants you to build a page containing a list of all of the books in the database, showing only their titles. The standard Django approach to this would be as follows: def book_list ( request ): queryset = Book . objects . all () return render ( \"book_list.html\" , { \"books\" : queryset }) <ul> {% for book in books %} <li> {{ book.title }} </li> {% endfor %} </ul> The queryset of books is passed into the template, and inside the for loop we have instances of the Book model. When the queryset is iterated, a database query something like this will be executed: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" , \"books_book\" . \"publisher_id\" , \"books_book\" . \"publication_date\" FROM \"books_book\" Note Notice that the SELECT part of the query is fetching more data than it really needs. We only actually need the title field, but we're also getting the id , publisher_id and publication_date . This is just how Django's ORM works: it has no way of knowing which fields you need when you run the query, so it just asks for all of them. This isn't normally a problem, but if your model has lots of fields (or large amounts of data in particular fields), it certainly can impact performance. You can control this behaviour with the .only and .defer queryset methods, but this is a manual optimisation and can be brittle. Requirement 2: add the publisher name for each book (without django-readers ) \u00b6 Now, the client wants you to show the name of the publisher after the book title. This looks like it should just involve a tweak to the HTML template, so we pass this work over to our frontend developer, who changes the template so it looks like this: <ul> {% for book in books %} <li> {{ book.title }} published by {{ book.publisher.name }} </li> {% endfor %} </ul> But there's a problem here. Django's ORM is being asked to follow a relationship (from Book to Publisher via the publisher foreign key). In order to do that, it has to issue another query to the database to fetch all the details of the publisher: SELECT \"books_publisher\" . \"id\" , \"books_publisher\" . \"name\" , \"books_publisher\" . \"address\" FROM \"books_book\" WHERE \"books_book\" . \"id\" = 1 Because we're following this relationship inside a loop in the template, the ORM will issue a query like this for each book in the list . This is the \" N+1 queries problem \": there's one query to fetch all the books, then N queries (where N is the number of books) to fetch the publisher for each book. This can be disastrous for performance. Django provides tools to fix this. In this case, we'd probably use the select_related queryset method in the view, like this: def book_list ( request ): queryset = Book . objects . select_related ( \"publisher\" ) return render ( \"book_list.html\" , { \"books\" : queryset }) This tells the ORM to issue a JOIN to fetch all the data in one query: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" , \"books_book\" . \"publisher_id\" , \"books_book\" . \"publication_date\" , \"books_publisher\" . \"id\" , \"books_publisher\" . \"name\" , \"books_publisher\" . \"address\" FROM \"books_book\" LEFT OUTER JOIN \"books_publisher\" ON ( \"books_book\" . \"publisher_id\" = \"books_publisher\" . \"id\" ) The problem with this is that the view code and the template code are now coupled in a very unpredictable and hard-to-reason-about way. A small, innocuous-looking change to the code in either the view or template can drastically impact the performance. This coupling problem only gets worse as the complexity of the application increases. django-readers takes a different approach. We explicitly perform all data fetching in the view. The template then deals only with presentation: instead of passing a queryset into the template and allowing the template code to access arbitrary attributes or methods on the model instances, we instead extract precisely the data we need from the database, convert it into basic data structures (Python dictionaries) and pass those into the template instead. This means that template authors can't blindly follow relationships and incur extra queries, because the attributes that express those relationships simply don't exist in the template context. To mitigate the burden of having to fine-tune querysets by hand for efficiency, a high-level \"spec\" is used to describe exactly which fields and relationships are needed, and django-readers is responsible for building the queryset and converting the model instances into dictionaries. For more on the motivation behind django-readers , see the Explanation page . Requirement 1 revisited: a list of book titles (with django-readers ) \u00b6 Let's go back to the initial requirement: just show a list of book titles. Remember that we only needed the title field, but Django wastefully extracted all of the fields on the Book model from the database. django-readers fixes this: from django_readers import specs def book_list ( request ): spec = [ \"title\" , ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) As you can see, at its simplest a django-readers spec is just a list of field names. specs.process takes the spec and returns a pair of functions . By convention, we call these functions prepare and project . Note prepare and project are django-readers -specific terms. There is one other django-readers concept beginning with P, produce , which will be introduced fully later, but here are their rough definitions to set the scene: A prepare function (a \"queryset function\") takes a queryset and returns a clone of the queryset with one or more modifications applied, such as prefetch_related , filter , only etc. This is called \"preparing the queryset\". Queryset functions can be composed, just like chaining queryset methods. A produce function (a \"producer\") takes a model instance and returns (\"produces\") a value derived from that instance. Often this is the value of an attribute on the model. A project function (a \"projector\") is similar to a producer in that it takes a model instance, but rather than returning just a value, it returns a dictionary (the \"projection\") mapping one or more names (the dictionary keys) to one or more values derived from the instance (often the values of one or more attributes and possibly nested dictionaries representing related models). It projects your data layer into your application's business logic domain. Think of the dictionary returned by a projector as the simplest possible domain object. Generally speaking, it's not necessary to write your own projector functions: django-readers comes with a producer_to_projector utility that takes a producer function and a name, and creates a projector function that returns a dictionary mapping the name to the value returned by the producer. The prepare function is responsible for building the queryset. It takes a queryset as an argument (in this case Book.objects.all() ) and returns a new queryset that is fine-tuned to fetch only the data we're interested in. When we evaluate the prepared queryset, Django can now issue a much more optimised query to the database: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" FROM \"books_book\" We still need the id field (Django uses the primary key to track the identity of the model instance so it's always included) but apart from that, we only get the title : just what we need. The project function operates on model instances. It takes an instance as its argument and returns a dictionary containing only the fields we've asked for in the spec. So in this case, it might return: { \"title\" : \"Pro Django\" } We iterate over the queryset and call this project function on each model instance, and pass the resulting list of dictionaries into the template: [ { \"title\" : \"Pro Django\" }, { \"title\" : \"Two Scoops of Django\" }, { \"title\" : \"Speed Up Your Django Tests\" }, ] Requirement 2 revisited: add the publisher name for each book (with django-readers ) \u00b6 Selecting only the required subset of fields from a model is a neat trick, but django-readers really comes into its own when dealing with relationships between models. A relationship in a django-readers spec is expressed as a dictionary with (usually) a single key and value, the key being the name of the relationship field on the model and the value being another spec, listing the fields we need from the model on the other side of the relationship. To include the publisher name, our spec would look like this: from django_readers import specs def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) Now, the prepare function (as well as selecting only the title field) adds a prefetch_related to the Book queryset to fetch the related Publisher . By providing the list of fields we want from the Publisher too, django-readers can make sure it efficiently builds the related Publisher queryset in just the same way. Now we get two queries, one to fetch the books: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" , \"books_book\" . \"publisher_id\" FROM \"books_book\" And one to fetch all the publishers for those books: SELECT \"books_publisher\" . \"id\" , \"books_publisher\" . \"name\" FROM \"books_publisher\" WHERE \"books_publisher\" . \"id\" IN ( 1 , 2 , 3 ) Note Note that django-readers always uses prefetch_related to load relationships, even in circumstances where select_related would usually be used (i.e. ForeignKey and OneToOneField ), resulting in one query per relationship. This approach allows the code to be \"fractal\": the tree of specs can be recursively applied to the tree of related querysets. Using prefetch_related for foreign key relationships does have some drawbacks: the \"join\" between books and publishers is performed in Python, rather than in the database. This can be can be slower and use more memory. Of course, using prefetch_related is (usually) still much better than doing nothing and emitting N queries! It is also quite possible to build queries with django-readers that do use select_related (i.e. perform joins in the database), but this must be done in a more manual way. We'll cover this elsewhere in the docs. The project function then includes the fields we asked for from the related objects too, so after iterating over the queryset and projecting each instance, the value of the books variable in the template context will be: [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" }, }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" }, }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" }, }, ] Requirement 3: Add author names for each book \u00b6 This requirement is quite straightforward, as it's very similar to the previous requirement. <ul> {% for book in books %} <li> {{ book.title }} published by {{ book.publisher.name }} Authors: <ul> {% for author in book.authors %} <li> {{ author.name }} </li> {% endfor %} </ul> </li> {% endfor %} </ul> The spec changes to include the new relationship: from django_readers import specs def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , ] }, { \"authors\" : [ \"name\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) As you can see, foreign key relationships and many-to-many relationships are represented in a spec in exactly the same way. The value of the books variable in the template context will now be: [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" }, \"authors\" : [ { \"name\" : \"Marty Alchin\" }, ], }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" }, \"authors\" : [ { \"name\" : \"Daniel Roy Greenfeld\" }, { \"name\" : \"Audrey Roy Greenfeld\" }, ], }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" }, \"authors\" : [ { \"name\" : \"Adam Johnson\" }, ], }, ] Requirement 4: include a count of published books with each publisher \u00b6 Now, the client wants you to include a count of how many books each publisher has published alongside the name of the publisher. How would we accomplish this with django-readers ? So far, we've only seen two types of value inside a spec: strings (representing the name of a field on the model) and dictionaries with string keys and list values (representing a relationship to another model). But we can also completely customise the spec to do whatever we want. This is how django-readers scales to accomodate to arbitrarily complex requirements. django-readers comes with a library of functions that can be used to add commonly-used aggregations to a spec, such as counting related objects. These are included in a spec using the same single-key-dictionary syntax as we've already seen for relationships: from django_readers import pairs , specs def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ] }, { \"authors\" : [ \"name\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) Requirement 5: identifying \"vintage\" books \u00b6 The client has a new requirement: for books that were published more than five years ago, they want to add a \"vintage\" label alongside the book title. There are a few places you could put the business logic to implement this requirement, including in the view and in the template. Common best practice in the Django community would be to put this logic in a method on the Book model, like this: from datetime import date class Book ( models . Model ): title = models . CharField ( max_length = 100 ) authors = models . ManyToManyField ( Author ) publisher = models . ForeignKey ( Publisher ) publication_date = models . DateField () def is_vintage ( self ): years_since_publication = date . today () . year - self . publication_date . year return years_since_publication > 5 Putting business logic on the model is known as a \"fat models\" approach. However, experience has shown that there are problems with this, particularly in larger codebases (see the Explanation page for details). Instead, django-readers encourages you to put logic like this in a standalone function. This function takes a model instance as its argument and returns a value. As described above, we call this type of function a producer . from datetime import date def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 Now, in order to make the database query efficient, you need to identify the data dependencies of this producer function. Which fields from the model does it need to do its work? By looking at the code, you can see that it uses just one field from the model: the publication_date . So, as well as writing the producer function, you need to create a queryset function that prepares the queryset by including this publication_date field in the query. django-readers comes with a library of functions under django_readers.qs that help with creating queryset functions. In this case, you need to use the include_fields function: from datetime import date from django_readers import qs prepare_is_vintage = qs . include_fields ( \"publication_date\" ) def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 Finally, to express the dependency between the producer function and the queryset function, the two functions are put together in a tuple called a reader pair (or, commonly, just a \"pair\"): from datetime import date from django_readers import qs prepare_is_vintage = qs . include_fields ( \"publication_date\" ) def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 is_vintage = ( prepare_is_vintage , produce_is_vintage ) Now you've have a created your custom pair, you can use it in your spec. Again we use the dictionary syntax: from datetime import date from django_readers import pairs , qs , specs prepare_is_vintage = qs . include_fields ( \"publication_date\" ) def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 is_vintage = ( prepare_is_vintage , produce_is_vintage ) def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ] }, { \"authors\" : [ \"name\" , ] }, { \"is_vintage\" : is_vintage } ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) Note For this example, we've put the code for the pair (the prepare and produce function) in the same Python file as the view function. You may choose to put your django-readers code in a separate file, perhaps called readers.py . You can follow whichever naming convention makes sense for your project layout. The value of the books variable in the template context will now be: [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" , \"published_book_count\" : 1 , }, \"authors\" : [ { \"name\" : \"Marty Alchin\" }, ], \"is_vintage\" : True , }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" , \"published_book_count\" : 1 , }, \"authors\" : [ { \"name\" : \"Daniel Roy Greenfeld\" }, { \"name\" : \"Audrey Roy Greenfeld\" }, ], \"is_vintage\" : True , }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" , \"published_book_count\" : 1 , }, \"authors\" : [ { \"name\" : \"Adam Johnson\" }, ], \"is_vintage\" : False , }, ] Requirement 6: add an API endpoint to list books \u00b6 The client has now decided that it's time to build a JavaScript frontend for their website, and wants to expose the book data via an API endpoint rather than rendering the HTML on the server. The best way to build APIs with Django is to use Django REST framework . django-readers provides a mixin that allows you to use a spec to define the \"shape\" of the data that the endpoint should return. As we've already seen, django-readers will extract this data from the database as efficiently as it can. This makes it very quick to build endpoints without compromising on performance. We're going to illustrate this by re-using the spec from the previous section. To avoid repeating the example code again, we're going to assume that the is_vintage pair is defined already. from django_readers.rest_framework import SpecMixin from rest_framework.generics import ListAPIView class BookListView ( SpecMixin , ListAPIView ): queryset = Book . objects . all () spec = [ \"title\" , { \"publisher\" : [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ] }, { \"authors\" : [ \"name\" , ] }, { \"is_vintage\" : is_vintage }, ] Once you've wired up this view in your urls.py you can start making requests to it. The JSON data returned from this endpoint will be exactly the same \"shape\" as the template context above: GET /api/books/ HTTP 200 OK Allow: GET, HEAD, OPTIONS Content-Type: application/json Vary: Accept { \"count\" : 3 , \"next\" : null , \"previous\" : null , \"results\" : [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" , \"published_book_count\" : 1 }, \"authors\" : [ { \"name\" : \"Marty Alchin\" } ], \"is_vintage\" : true }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" , \"published_book_count\" : 1 }, \"authors\" : [ { \"name\" : \"Daniel Roy Greenfeld\" }, { \"name\" : \"Audrey Roy Greenfeld\" } ], \"is_vintage\" : true }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" , \"published_book_count\" : 1 }, \"authors\" : [ { \"name\" : \"Adam Johnson\" } ], \"is_vintage\" : false } ] } A note on django-zen-queries \u00b6 An important pattern to avoid inefficient database queries in Django projects is to isolate the fetching of data from the rendering of data . This pattern can be implemented with the help of django-zen-queries , a library that allows you to mark blocks of code under which database queries are not allowed. In a project using django-readers , it is good practice to disallow queries in the prepare and project phases: import zen_queries prepare , project = specs . process ( [ # some spec ] ) with zen_queries . queries_disabled (): queryset = prepare ( Author . objects . all ()) queryset = zen_queries . fetch ( queryset ) # execute the database queries with zen_queries . queries_disabled (): result = [ project ( instance ) for instance in queryset ] # ...render result as JSON or in a template To enforce this, if django-zen-queries is installed (which is recommended!), django-readers will automatically apply queries_disabled() to the prepare and project functions returned by specs.process , so there is no need to apply it manually as in the above example .","title":"Tutorial"},{"location":"tutorial/#installing-django-readers","text":"Install from PyPI : pip install django-readers","title":"Installing django-readers"},{"location":"tutorial/#prerequisites","text":"This tutorial assumes you understand the basics of Django (models, views, templates etc). Make sure you've been through the Django tutorial first. The section on Django REST framework assumes that you've read and understood the docs .","title":"Prerequisites"},{"location":"tutorial/#example-models","text":"For the purposes of this tutorial, we're going to use a set of models representing books , authors and publishers . A book has exactly one publisher, but can have many authors. Here are the Django models we're using: class Publisher ( models . Model ): name = models . CharField ( max_length = 100 ) address = models . TextField () class Author ( models . Model ): name = models . CharField ( max_length = 100 ) email = models . EmailField () class Book ( models . Model ): title = models . CharField ( max_length = 100 ) authors = models . ManyToManyField ( Author ) publisher = models . ForeignKey ( Publisher ) publication_date = models . DateField () We're going to go through a step-by-step set of requirements from an imaginary client who has asked you to build a simple book listing application. We're going to assume the Django project itself has already been set up, and focus on a single view and a single template.","title":"Example models"},{"location":"tutorial/#requirement-1-a-list-of-book-titles-without-django-readers","text":"First, the client wants you to build a page containing a list of all of the books in the database, showing only their titles. The standard Django approach to this would be as follows: def book_list ( request ): queryset = Book . objects . all () return render ( \"book_list.html\" , { \"books\" : queryset }) <ul> {% for book in books %} <li> {{ book.title }} </li> {% endfor %} </ul> The queryset of books is passed into the template, and inside the for loop we have instances of the Book model. When the queryset is iterated, a database query something like this will be executed: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" , \"books_book\" . \"publisher_id\" , \"books_book\" . \"publication_date\" FROM \"books_book\" Note Notice that the SELECT part of the query is fetching more data than it really needs. We only actually need the title field, but we're also getting the id , publisher_id and publication_date . This is just how Django's ORM works: it has no way of knowing which fields you need when you run the query, so it just asks for all of them. This isn't normally a problem, but if your model has lots of fields (or large amounts of data in particular fields), it certainly can impact performance. You can control this behaviour with the .only and .defer queryset methods, but this is a manual optimisation and can be brittle.","title":"Requirement 1: a list of book titles (without django-readers)"},{"location":"tutorial/#requirement-2-add-the-publisher-name-for-each-book-without-django-readers","text":"Now, the client wants you to show the name of the publisher after the book title. This looks like it should just involve a tweak to the HTML template, so we pass this work over to our frontend developer, who changes the template so it looks like this: <ul> {% for book in books %} <li> {{ book.title }} published by {{ book.publisher.name }} </li> {% endfor %} </ul> But there's a problem here. Django's ORM is being asked to follow a relationship (from Book to Publisher via the publisher foreign key). In order to do that, it has to issue another query to the database to fetch all the details of the publisher: SELECT \"books_publisher\" . \"id\" , \"books_publisher\" . \"name\" , \"books_publisher\" . \"address\" FROM \"books_book\" WHERE \"books_book\" . \"id\" = 1 Because we're following this relationship inside a loop in the template, the ORM will issue a query like this for each book in the list . This is the \" N+1 queries problem \": there's one query to fetch all the books, then N queries (where N is the number of books) to fetch the publisher for each book. This can be disastrous for performance. Django provides tools to fix this. In this case, we'd probably use the select_related queryset method in the view, like this: def book_list ( request ): queryset = Book . objects . select_related ( \"publisher\" ) return render ( \"book_list.html\" , { \"books\" : queryset }) This tells the ORM to issue a JOIN to fetch all the data in one query: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" , \"books_book\" . \"publisher_id\" , \"books_book\" . \"publication_date\" , \"books_publisher\" . \"id\" , \"books_publisher\" . \"name\" , \"books_publisher\" . \"address\" FROM \"books_book\" LEFT OUTER JOIN \"books_publisher\" ON ( \"books_book\" . \"publisher_id\" = \"books_publisher\" . \"id\" ) The problem with this is that the view code and the template code are now coupled in a very unpredictable and hard-to-reason-about way. A small, innocuous-looking change to the code in either the view or template can drastically impact the performance. This coupling problem only gets worse as the complexity of the application increases. django-readers takes a different approach. We explicitly perform all data fetching in the view. The template then deals only with presentation: instead of passing a queryset into the template and allowing the template code to access arbitrary attributes or methods on the model instances, we instead extract precisely the data we need from the database, convert it into basic data structures (Python dictionaries) and pass those into the template instead. This means that template authors can't blindly follow relationships and incur extra queries, because the attributes that express those relationships simply don't exist in the template context. To mitigate the burden of having to fine-tune querysets by hand for efficiency, a high-level \"spec\" is used to describe exactly which fields and relationships are needed, and django-readers is responsible for building the queryset and converting the model instances into dictionaries. For more on the motivation behind django-readers , see the Explanation page .","title":"Requirement 2: add the publisher name for each book (without django-readers)"},{"location":"tutorial/#requirement-1-revisited-a-list-of-book-titles-with-django-readers","text":"Let's go back to the initial requirement: just show a list of book titles. Remember that we only needed the title field, but Django wastefully extracted all of the fields on the Book model from the database. django-readers fixes this: from django_readers import specs def book_list ( request ): spec = [ \"title\" , ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) As you can see, at its simplest a django-readers spec is just a list of field names. specs.process takes the spec and returns a pair of functions . By convention, we call these functions prepare and project . Note prepare and project are django-readers -specific terms. There is one other django-readers concept beginning with P, produce , which will be introduced fully later, but here are their rough definitions to set the scene: A prepare function (a \"queryset function\") takes a queryset and returns a clone of the queryset with one or more modifications applied, such as prefetch_related , filter , only etc. This is called \"preparing the queryset\". Queryset functions can be composed, just like chaining queryset methods. A produce function (a \"producer\") takes a model instance and returns (\"produces\") a value derived from that instance. Often this is the value of an attribute on the model. A project function (a \"projector\") is similar to a producer in that it takes a model instance, but rather than returning just a value, it returns a dictionary (the \"projection\") mapping one or more names (the dictionary keys) to one or more values derived from the instance (often the values of one or more attributes and possibly nested dictionaries representing related models). It projects your data layer into your application's business logic domain. Think of the dictionary returned by a projector as the simplest possible domain object. Generally speaking, it's not necessary to write your own projector functions: django-readers comes with a producer_to_projector utility that takes a producer function and a name, and creates a projector function that returns a dictionary mapping the name to the value returned by the producer. The prepare function is responsible for building the queryset. It takes a queryset as an argument (in this case Book.objects.all() ) and returns a new queryset that is fine-tuned to fetch only the data we're interested in. When we evaluate the prepared queryset, Django can now issue a much more optimised query to the database: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" FROM \"books_book\" We still need the id field (Django uses the primary key to track the identity of the model instance so it's always included) but apart from that, we only get the title : just what we need. The project function operates on model instances. It takes an instance as its argument and returns a dictionary containing only the fields we've asked for in the spec. So in this case, it might return: { \"title\" : \"Pro Django\" } We iterate over the queryset and call this project function on each model instance, and pass the resulting list of dictionaries into the template: [ { \"title\" : \"Pro Django\" }, { \"title\" : \"Two Scoops of Django\" }, { \"title\" : \"Speed Up Your Django Tests\" }, ]","title":"Requirement 1 revisited: a list of book titles (with django-readers)"},{"location":"tutorial/#requirement-2-revisited-add-the-publisher-name-for-each-book-with-django-readers","text":"Selecting only the required subset of fields from a model is a neat trick, but django-readers really comes into its own when dealing with relationships between models. A relationship in a django-readers spec is expressed as a dictionary with (usually) a single key and value, the key being the name of the relationship field on the model and the value being another spec, listing the fields we need from the model on the other side of the relationship. To include the publisher name, our spec would look like this: from django_readers import specs def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) Now, the prepare function (as well as selecting only the title field) adds a prefetch_related to the Book queryset to fetch the related Publisher . By providing the list of fields we want from the Publisher too, django-readers can make sure it efficiently builds the related Publisher queryset in just the same way. Now we get two queries, one to fetch the books: SELECT \"books_book\" . \"id\" , \"books_book\" . \"title\" , \"books_book\" . \"publisher_id\" FROM \"books_book\" And one to fetch all the publishers for those books: SELECT \"books_publisher\" . \"id\" , \"books_publisher\" . \"name\" FROM \"books_publisher\" WHERE \"books_publisher\" . \"id\" IN ( 1 , 2 , 3 ) Note Note that django-readers always uses prefetch_related to load relationships, even in circumstances where select_related would usually be used (i.e. ForeignKey and OneToOneField ), resulting in one query per relationship. This approach allows the code to be \"fractal\": the tree of specs can be recursively applied to the tree of related querysets. Using prefetch_related for foreign key relationships does have some drawbacks: the \"join\" between books and publishers is performed in Python, rather than in the database. This can be can be slower and use more memory. Of course, using prefetch_related is (usually) still much better than doing nothing and emitting N queries! It is also quite possible to build queries with django-readers that do use select_related (i.e. perform joins in the database), but this must be done in a more manual way. We'll cover this elsewhere in the docs. The project function then includes the fields we asked for from the related objects too, so after iterating over the queryset and projecting each instance, the value of the books variable in the template context will be: [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" }, }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" }, }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" }, }, ]","title":"Requirement 2 revisited: add the publisher name for each book (with django-readers)"},{"location":"tutorial/#requirement-3-add-author-names-for-each-book","text":"This requirement is quite straightforward, as it's very similar to the previous requirement. <ul> {% for book in books %} <li> {{ book.title }} published by {{ book.publisher.name }} Authors: <ul> {% for author in book.authors %} <li> {{ author.name }} </li> {% endfor %} </ul> </li> {% endfor %} </ul> The spec changes to include the new relationship: from django_readers import specs def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , ] }, { \"authors\" : [ \"name\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) As you can see, foreign key relationships and many-to-many relationships are represented in a spec in exactly the same way. The value of the books variable in the template context will now be: [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" }, \"authors\" : [ { \"name\" : \"Marty Alchin\" }, ], }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" }, \"authors\" : [ { \"name\" : \"Daniel Roy Greenfeld\" }, { \"name\" : \"Audrey Roy Greenfeld\" }, ], }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" }, \"authors\" : [ { \"name\" : \"Adam Johnson\" }, ], }, ]","title":"Requirement 3: Add author names for each book"},{"location":"tutorial/#requirement-4-include-a-count-of-published-books-with-each-publisher","text":"Now, the client wants you to include a count of how many books each publisher has published alongside the name of the publisher. How would we accomplish this with django-readers ? So far, we've only seen two types of value inside a spec: strings (representing the name of a field on the model) and dictionaries with string keys and list values (representing a relationship to another model). But we can also completely customise the spec to do whatever we want. This is how django-readers scales to accomodate to arbitrarily complex requirements. django-readers comes with a library of functions that can be used to add commonly-used aggregations to a spec, such as counting related objects. These are included in a spec using the same single-key-dictionary syntax as we've already seen for relationships: from django_readers import pairs , specs def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ] }, { \"authors\" : [ \"name\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, )","title":"Requirement 4: include a count of published books with each publisher"},{"location":"tutorial/#requirement-5-identifying-vintage-books","text":"The client has a new requirement: for books that were published more than five years ago, they want to add a \"vintage\" label alongside the book title. There are a few places you could put the business logic to implement this requirement, including in the view and in the template. Common best practice in the Django community would be to put this logic in a method on the Book model, like this: from datetime import date class Book ( models . Model ): title = models . CharField ( max_length = 100 ) authors = models . ManyToManyField ( Author ) publisher = models . ForeignKey ( Publisher ) publication_date = models . DateField () def is_vintage ( self ): years_since_publication = date . today () . year - self . publication_date . year return years_since_publication > 5 Putting business logic on the model is known as a \"fat models\" approach. However, experience has shown that there are problems with this, particularly in larger codebases (see the Explanation page for details). Instead, django-readers encourages you to put logic like this in a standalone function. This function takes a model instance as its argument and returns a value. As described above, we call this type of function a producer . from datetime import date def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 Now, in order to make the database query efficient, you need to identify the data dependencies of this producer function. Which fields from the model does it need to do its work? By looking at the code, you can see that it uses just one field from the model: the publication_date . So, as well as writing the producer function, you need to create a queryset function that prepares the queryset by including this publication_date field in the query. django-readers comes with a library of functions under django_readers.qs that help with creating queryset functions. In this case, you need to use the include_fields function: from datetime import date from django_readers import qs prepare_is_vintage = qs . include_fields ( \"publication_date\" ) def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 Finally, to express the dependency between the producer function and the queryset function, the two functions are put together in a tuple called a reader pair (or, commonly, just a \"pair\"): from datetime import date from django_readers import qs prepare_is_vintage = qs . include_fields ( \"publication_date\" ) def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 is_vintage = ( prepare_is_vintage , produce_is_vintage ) Now you've have a created your custom pair, you can use it in your spec. Again we use the dictionary syntax: from datetime import date from django_readers import pairs , qs , specs prepare_is_vintage = qs . include_fields ( \"publication_date\" ) def produce_is_vintage ( book ): years_since_publication = date . today () . year - book . publication_date . year return years_since_publication > 5 is_vintage = ( prepare_is_vintage , produce_is_vintage ) def book_list ( request ): spec = [ \"title\" , { \"publisher\" : [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ] }, { \"authors\" : [ \"name\" , ] }, { \"is_vintage\" : is_vintage } ] prepare , project = specs . process ( spec ) queryset = prepare ( Book . objects . all ()) return render ( \"book_list.html\" , { \"books\" : [ project ( book ) for book in queryset ]}, ) Note For this example, we've put the code for the pair (the prepare and produce function) in the same Python file as the view function. You may choose to put your django-readers code in a separate file, perhaps called readers.py . You can follow whichever naming convention makes sense for your project layout. The value of the books variable in the template context will now be: [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" , \"published_book_count\" : 1 , }, \"authors\" : [ { \"name\" : \"Marty Alchin\" }, ], \"is_vintage\" : True , }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" , \"published_book_count\" : 1 , }, \"authors\" : [ { \"name\" : \"Daniel Roy Greenfeld\" }, { \"name\" : \"Audrey Roy Greenfeld\" }, ], \"is_vintage\" : True , }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" , \"published_book_count\" : 1 , }, \"authors\" : [ { \"name\" : \"Adam Johnson\" }, ], \"is_vintage\" : False , }, ]","title":"Requirement 5: identifying \"vintage\" books"},{"location":"tutorial/#requirement-6-add-an-api-endpoint-to-list-books","text":"The client has now decided that it's time to build a JavaScript frontend for their website, and wants to expose the book data via an API endpoint rather than rendering the HTML on the server. The best way to build APIs with Django is to use Django REST framework . django-readers provides a mixin that allows you to use a spec to define the \"shape\" of the data that the endpoint should return. As we've already seen, django-readers will extract this data from the database as efficiently as it can. This makes it very quick to build endpoints without compromising on performance. We're going to illustrate this by re-using the spec from the previous section. To avoid repeating the example code again, we're going to assume that the is_vintage pair is defined already. from django_readers.rest_framework import SpecMixin from rest_framework.generics import ListAPIView class BookListView ( SpecMixin , ListAPIView ): queryset = Book . objects . all () spec = [ \"title\" , { \"publisher\" : [ \"name\" , { \"published_book_count\" : pairs . count ( \"book\" )}, ] }, { \"authors\" : [ \"name\" , ] }, { \"is_vintage\" : is_vintage }, ] Once you've wired up this view in your urls.py you can start making requests to it. The JSON data returned from this endpoint will be exactly the same \"shape\" as the template context above: GET /api/books/ HTTP 200 OK Allow: GET, HEAD, OPTIONS Content-Type: application/json Vary: Accept { \"count\" : 3 , \"next\" : null , \"previous\" : null , \"results\" : [ { \"title\" : \"Pro Django\" , \"publisher\" : { \"name\" : \"Apress\" , \"published_book_count\" : 1 }, \"authors\" : [ { \"name\" : \"Marty Alchin\" } ], \"is_vintage\" : true }, { \"title\" : \"Two Scoops of Django\" , \"publisher\" : { \"name\" : \"Two Scoops Press\" , \"published_book_count\" : 1 }, \"authors\" : [ { \"name\" : \"Daniel Roy Greenfeld\" }, { \"name\" : \"Audrey Roy Greenfeld\" } ], \"is_vintage\" : true }, { \"title\" : \"Speed Up Your Django Tests\" , \"publisher\" : { \"name\" : \"Gumroad\" , \"published_book_count\" : 1 }, \"authors\" : [ { \"name\" : \"Adam Johnson\" } ], \"is_vintage\" : false } ] }","title":"Requirement 6: add an API endpoint to list books"},{"location":"tutorial/#a-note-on-django-zen-queries","text":"An important pattern to avoid inefficient database queries in Django projects is to isolate the fetching of data from the rendering of data . This pattern can be implemented with the help of django-zen-queries , a library that allows you to mark blocks of code under which database queries are not allowed. In a project using django-readers , it is good practice to disallow queries in the prepare and project phases: import zen_queries prepare , project = specs . process ( [ # some spec ] ) with zen_queries . queries_disabled (): queryset = prepare ( Author . objects . all ()) queryset = zen_queries . fetch ( queryset ) # execute the database queries with zen_queries . queries_disabled (): result = [ project ( instance ) for instance in queryset ] # ...render result as JSON or in a template To enforce this, if django-zen-queries is installed (which is recommended!), django-readers will automatically apply queries_disabled() to the prepare and project functions returned by specs.process , so there is no need to apply it manually as in the above example .","title":"A note on django-zen-queries"},{"location":"community/changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] \u00b6 [2.5.1] - 2025-11-03 \u00b6 Fixed \u00b6 Correct serializer generation to add allow_null=True to reverse 1-to-1 relationships ( #114 ) Added \u00b6 Added Python 3.14 to test matrix and dropped Python 3.9 [2.5.0] - 2025-05-23 \u00b6 Added \u00b6 Added qs.alias function to support the .alias() QuerySet method ( #109 ). Added pairs.alias function to support aliasing in a spec. ( #112 ). [2.4.0] - 2025-04-03 \u00b6 Added \u00b6 Added support for using Python type objects instead of serializer fields in schema generation code ( #106 ) Added Django 5.2 and Python 3.13 to test matrix ( #107 ) [2.3.0] - 2024-04-17 \u00b6 Added \u00b6 Added support for overriding field kwargs for autogenerated serializer fields via out mechanism ( #99 ). [2.2.0] - 2024-01-12 \u00b6 Added \u00b6 Added support for Django's reverse generic relations ( GenericRelation model field) ( #93 ). Changed \u00b6 Add support for Django 5.0 [2.1.2] - 2023-07-17 \u00b6 Fixed \u00b6 Fix an error when using the @out decorator on producer functions that return values like booleans, that can't have arbitrary attributes added to them ( #86 ). Changed \u00b6 Add support for Django 4.2 Drop support for Python 3.7 [2.1.1] - 2023-03-21 \u00b6 Fixed \u00b6 Correctly set the allow_null attribute on nested serializers ( #81 ) [2.1.0] - 2023-01-13 \u00b6 Changed \u00b6 Add support for Django 4.1 Drop support for Django 2.2 Add support for Python 3.11 Drop support for Python 3.6 Added \u00b6 In the Django REST framework layer, callables in a spec are now automatically called and passed the request object ( #76 ) Support for generating a Django REST framework serializer from a spec, and for annotating custom pairs in a spec with their output field types. This enables automatic schema generation. ( #76 ) [2.0.0] - 2022-07-19 \u00b6 Changed \u00b6 BACKWARDS INCOMPATIBLE : The default value of the distinct argument for the pairs.count and pairs.has functions has changed from True to False . This now matches the default value of the distinct arguments to Django's Count annotation. To retain current behaviour, add distinct=True to all calls to these two functions in your codebase. For background on this decision, see this discussion . Added \u00b6 Proper documentation! https://www.django-readers.org New pairs.annotate function allowing you to annotate a queryset with aggregates, functions etc and produce the result. New pairs.sum function to annotate a queryset with the Sum aggregate function and produce the result. [1.1.0] - 2022-02-23 \u00b6 Added \u00b6 New pairs.discard_queryset_function and pairs.discard_projector functions to discard one or other item in a reader pair. Changed \u00b6 SpecMixin now applies prepare function in get_queryset , not filter_queryset [1.0.0] - 2021-10-13 \u00b6 Initial stable release.","title":"Changelog"},{"location":"community/changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"community/changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"community/changelog/#251-2025-11-03","text":"","title":"[2.5.1] - 2025-11-03"},{"location":"community/changelog/#fixed","text":"Correct serializer generation to add allow_null=True to reverse 1-to-1 relationships ( #114 )","title":"Fixed"},{"location":"community/changelog/#added","text":"Added Python 3.14 to test matrix and dropped Python 3.9","title":"Added"},{"location":"community/changelog/#250-2025-05-23","text":"","title":"[2.5.0] - 2025-05-23"},{"location":"community/changelog/#added_1","text":"Added qs.alias function to support the .alias() QuerySet method ( #109 ). Added pairs.alias function to support aliasing in a spec. ( #112 ).","title":"Added"},{"location":"community/changelog/#240-2025-04-03","text":"","title":"[2.4.0] - 2025-04-03"},{"location":"community/changelog/#added_2","text":"Added support for using Python type objects instead of serializer fields in schema generation code ( #106 ) Added Django 5.2 and Python 3.13 to test matrix ( #107 )","title":"Added"},{"location":"community/changelog/#230-2024-04-17","text":"","title":"[2.3.0] - 2024-04-17"},{"location":"community/changelog/#added_3","text":"Added support for overriding field kwargs for autogenerated serializer fields via out mechanism ( #99 ).","title":"Added"},{"location":"community/changelog/#220-2024-01-12","text":"","title":"[2.2.0] - 2024-01-12"},{"location":"community/changelog/#added_4","text":"Added support for Django's reverse generic relations ( GenericRelation model field) ( #93 ).","title":"Added"},{"location":"community/changelog/#changed","text":"Add support for Django 5.0","title":"Changed"},{"location":"community/changelog/#212-2023-07-17","text":"","title":"[2.1.2] - 2023-07-17"},{"location":"community/changelog/#fixed_1","text":"Fix an error when using the @out decorator on producer functions that return values like booleans, that can't have arbitrary attributes added to them ( #86 ).","title":"Fixed"},{"location":"community/changelog/#changed_1","text":"Add support for Django 4.2 Drop support for Python 3.7","title":"Changed"},{"location":"community/changelog/#211-2023-03-21","text":"","title":"[2.1.1] - 2023-03-21"},{"location":"community/changelog/#fixed_2","text":"Correctly set the allow_null attribute on nested serializers ( #81 )","title":"Fixed"},{"location":"community/changelog/#210-2023-01-13","text":"","title":"[2.1.0] - 2023-01-13"},{"location":"community/changelog/#changed_2","text":"Add support for Django 4.1 Drop support for Django 2.2 Add support for Python 3.11 Drop support for Python 3.6","title":"Changed"},{"location":"community/changelog/#added_5","text":"In the Django REST framework layer, callables in a spec are now automatically called and passed the request object ( #76 ) Support for generating a Django REST framework serializer from a spec, and for annotating custom pairs in a spec with their output field types. This enables automatic schema generation. ( #76 )","title":"Added"},{"location":"community/changelog/#200-2022-07-19","text":"","title":"[2.0.0] - 2022-07-19"},{"location":"community/changelog/#changed_3","text":"BACKWARDS INCOMPATIBLE : The default value of the distinct argument for the pairs.count and pairs.has functions has changed from True to False . This now matches the default value of the distinct arguments to Django's Count annotation. To retain current behaviour, add distinct=True to all calls to these two functions in your codebase. For background on this decision, see this discussion .","title":"Changed"},{"location":"community/changelog/#added_6","text":"Proper documentation! https://www.django-readers.org New pairs.annotate function allowing you to annotate a queryset with aggregates, functions etc and produce the result. New pairs.sum function to annotate a queryset with the Sum aggregate function and produce the result.","title":"Added"},{"location":"community/changelog/#110-2022-02-23","text":"","title":"[1.1.0] - 2022-02-23"},{"location":"community/changelog/#added_7","text":"New pairs.discard_queryset_function and pairs.discard_projector functions to discard one or other item in a reader pair.","title":"Added"},{"location":"community/changelog/#changed_4","text":"SpecMixin now applies prepare function in get_queryset , not filter_queryset","title":"Changed"},{"location":"community/changelog/#100-2021-10-13","text":"Initial stable release.","title":"[1.0.0] - 2021-10-13"},{"location":"community/license/","text":"BSD-2-Clause license Copyright (c) 2020, DabApps All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"community/third-party-packages/","text":"django-readers-debug \u00b6 A pretty-printer for debugging django-readers queryset functions.","title":"Third Party Packages"},{"location":"community/third-party-packages/#django-readers-debug","text":"A pretty-printer for debugging django-readers queryset functions.","title":"django-readers-debug"},{"location":"reference/pairs/","text":"Pair functions return a tuple of two functions: either (prepare, produce) (a \"producer pair\" consisting of a queryset function and a producer function ) or (prepare, project) (a \"projector pair\" consisting of a queryset function and a projector function ). The grouping of these two types of function represents a dependency: in order to call the producer (or projector) function on a model instance, you must first call the queryset function on the queryset that was used to retrieve the instance . Remember that the difference between a producer and a projector is that the former returns a single value, whereas the latter returns a dictionary binding one or more names (keys) to one or more values. In order to use a pair in a spec , it must be a projector pair, so that the values returned by each projector in the spec are associated with names (the keys) that can be used in the final projection. However, at the point where a pair is created in your codebase, you often don't know what the output key should be: you are only interested in the value derived from the instance. So it's almost always the case that custom pairs will be written as producer pairs, and converted to projector pairs at the point where they are used in a spec, either by using the pairs.producer_to_projector function or by using the shorthand syntax available in a spec . Import like this: from django_readers import pairs pairs.field(name, *, transform_value=None, transform_value_if_none=False) \u00b6 Returns a pair which loads and produces the value of a model field. from django_readers import pairs prepare , produce = pairs . field ( \"name\" ) queryset = prepare ( Author . objects . all ()) print ( queryset . query ) # SELECT \"author\".\"id\", \"author\".\"name\" FROM \"books_author\" print ( produce ( queryset . first ())) # 'Some Author' The pairs.field function takes the same transform_value and transform_value_if_none arguments as producers.attr . pairs.field_display(name) \u00b6 A pair function for working with Django's get_FOO_display mechanism. From the Django docs: For every field that has choices set, the object will have a get_FOO_display() method, where FOO is the name of the field. This method returns the \u201chuman-readable\u201d value of the field. The pairs.field_display function takes the field name as its single argument and returns a pair which loads the field from the database, and then produces the result of calling get_<field>_display . pairs.annotate(*args, **kwargs) \u00b6 Returns a pair that adds an annotation to the queryset and produces the annotated value. Like the annotate method on QuerySet , this can take either a positional argument (if the annotation function supports this) or a keyword argument. Unlike the annotate method, this can only handle a single annotation at a time. This function can optionally take transform_value and transform_value_if_none keyword arguments, which are passed to the producer . For example: from django.db.models.functions import ExtractYear from django_readers import pairs prepare , produce = pairs . annotate ( publication_year = ExtractYear ( \"publication_date\" ), ) queryset = prepare ( Book . objects . all ()) print ( queryset . query ) # SELECT \"book\".\"id\", EXTRACT('year' FROM \"book\".\"publication_date\" # AT TIME ZONE 'UTC') AS \"publication_year\" FROM \"books_book\" print ( produce ( queryset . first ())) # 2013 pairs.count(name, *args, **kwargs) \u00b6 Returns a pair which annotates a Count of the named relationship field onto the queryset, and produces its value. The *args and **kwargs parameters to this function are passed directly to the underlying Count annotation, so can be used to provide distinct and filter arguments. pairs.has(name, *args, **kwargs) \u00b6 Returns a pair which annotates a Count of the named relationship field onto the queryset, and produces a boolean representing whether or not that count is zero. The *args and **kwargs parameters to this function are passed directly to the underlying Count annotation, so can be used to provide distinct and filter arguments. pairs.sum(name, *args, **kwargs) \u00b6 Returns a pair which annotates a Count of the named relationship field onto the queryset, and produces its value. The *args and **kwargs parameters to this function are passed directly to the underlying Sum annotation, so can be used to provide distinct and filter arguments etc. pairs.filter(*args, **kwargs) \u00b6 Returns a pair consisting of a qs.filter queryset function, and a no-op projector . Most useful for filtering relationships. pairs.exclude(*args, **kwargs) \u00b6 Returns a pair consisting of a qs.exclude queryset function, and a no-op projector . Most useful for filtering relationships. pairs.order_by(*args, **kwargs) \u00b6 Returns a pair consisting of a qs.order_by queryset function, and a no-op projector . Most useful for ordering relationships. pairs.alias(*args, **kwargs) \u00b6 Returns a pair consisting of a qs.alias queryset function, and a no-op projector . Most useful for creating expressions that are later used for filtering or ordering, but aren't needed in the final result. Relationships \u00b6 The following pair functions return the various queryset functions that prefetch relationships of various types , and then produce those related objects . There are functions for forward, reverse or many-to-many relationships, and then a relationship function which selects the correct one by introspecting the model. It shouldn't usually be necessary to use the manual functions unless you're doing something weird, like providing a custom queryset. pairs.forward_relationship(name, related_queryset, relationship_pair, to_attr=None) \u00b6 See qs.prefetch_forward_relationship pairs.reverse_relationship(name, related_name, related_queryset, relationship_pair, to_attr=None) \u00b6 See qs.prefetch_reverse_relationship pairs.many_to_many_relationship(name, related_queryset, relationship_pair, to_attr=None) \u00b6 See qs.prefetch_many_to_many_relationship pairs.relationship(name, relationship_pair, to_attr=None) \u00b6 See qs.auto_prefetch_relationship pairs.pk_list(name, to_attr=None) \u00b6 Given an attribute name (which should be a relationship field), return a pair consisting of a queryset function which prefetches the relationship (including only the primary key of each related object) and a producer which returns a list of those primary keys (or just a single PK if this is a to-one field, but this is an inefficient way of doing it). See producers.pk_list Utilities \u00b6 The following functions are useful when working with pairs in your codebase. pairs.producer_to_projector(name, pair) \u00b6 Given a name (key) and a producer pair consisting of a queryset function and a producer function, returns a projector pair consisting of the same queryset function, and a projector function which returns a dictionary mapping the name to the value derived from the producer. pairs.combine(*pairs) \u00b6 Given a list of projector pairs as *args , return a pair which consists of a queryset function which pipes together the queryset function from each pair, and a projector which combines the projector function from each pair. pairs.discard_projector(pair) \u00b6 Given a pair, return only the first item in the pair (the queryset function). This is equivalent to pairs[0] , but using the function can make the intention clearer. pairs.discard_queryset_function(pair) \u00b6 Given a pair, return only the second item in the pair (the projector function). This is equivalent to pairs[1] , but using the function can make the intention clearer.","title":"Pairs"},{"location":"reference/pairs/#field","text":"Returns a pair which loads and produces the value of a model field. from django_readers import pairs prepare , produce = pairs . field ( \"name\" ) queryset = prepare ( Author . objects . all ()) print ( queryset . query ) # SELECT \"author\".\"id\", \"author\".\"name\" FROM \"books_author\" print ( produce ( queryset . first ())) # 'Some Author' The pairs.field function takes the same transform_value and transform_value_if_none arguments as producers.attr .","title":"pairs.field(name, *, transform_value=None, transform_value_if_none=False)"},{"location":"reference/pairs/#field_display","text":"A pair function for working with Django's get_FOO_display mechanism. From the Django docs: For every field that has choices set, the object will have a get_FOO_display() method, where FOO is the name of the field. This method returns the \u201chuman-readable\u201d value of the field. The pairs.field_display function takes the field name as its single argument and returns a pair which loads the field from the database, and then produces the result of calling get_<field>_display .","title":"pairs.field_display(name)"},{"location":"reference/pairs/#annotate","text":"Returns a pair that adds an annotation to the queryset and produces the annotated value. Like the annotate method on QuerySet , this can take either a positional argument (if the annotation function supports this) or a keyword argument. Unlike the annotate method, this can only handle a single annotation at a time. This function can optionally take transform_value and transform_value_if_none keyword arguments, which are passed to the producer . For example: from django.db.models.functions import ExtractYear from django_readers import pairs prepare , produce = pairs . annotate ( publication_year = ExtractYear ( \"publication_date\" ), ) queryset = prepare ( Book . objects . all ()) print ( queryset . query ) # SELECT \"book\".\"id\", EXTRACT('year' FROM \"book\".\"publication_date\" # AT TIME ZONE 'UTC') AS \"publication_year\" FROM \"books_book\" print ( produce ( queryset . first ())) # 2013","title":"pairs.annotate(*args, **kwargs)"},{"location":"reference/pairs/#count","text":"Returns a pair which annotates a Count of the named relationship field onto the queryset, and produces its value. The *args and **kwargs parameters to this function are passed directly to the underlying Count annotation, so can be used to provide distinct and filter arguments.","title":"pairs.count(name, *args, **kwargs)"},{"location":"reference/pairs/#has","text":"Returns a pair which annotates a Count of the named relationship field onto the queryset, and produces a boolean representing whether or not that count is zero. The *args and **kwargs parameters to this function are passed directly to the underlying Count annotation, so can be used to provide distinct and filter arguments.","title":"pairs.has(name, *args, **kwargs)"},{"location":"reference/pairs/#sum","text":"Returns a pair which annotates a Count of the named relationship field onto the queryset, and produces its value. The *args and **kwargs parameters to this function are passed directly to the underlying Sum annotation, so can be used to provide distinct and filter arguments etc.","title":"pairs.sum(name, *args, **kwargs)"},{"location":"reference/pairs/#filter","text":"Returns a pair consisting of a qs.filter queryset function, and a no-op projector . Most useful for filtering relationships.","title":"pairs.filter(*args, **kwargs)"},{"location":"reference/pairs/#exclude","text":"Returns a pair consisting of a qs.exclude queryset function, and a no-op projector . Most useful for filtering relationships.","title":"pairs.exclude(*args, **kwargs)"},{"location":"reference/pairs/#order_by","text":"Returns a pair consisting of a qs.order_by queryset function, and a no-op projector . Most useful for ordering relationships.","title":"pairs.order_by(*args, **kwargs)"},{"location":"reference/pairs/#order_by","text":"Returns a pair consisting of a qs.alias queryset function, and a no-op projector . Most useful for creating expressions that are later used for filtering or ordering, but aren't needed in the final result.","title":"pairs.order_by(*args, **kwargs)"},{"location":"reference/pairs/#relationships","text":"The following pair functions return the various queryset functions that prefetch relationships of various types , and then produce those related objects . There are functions for forward, reverse or many-to-many relationships, and then a relationship function which selects the correct one by introspecting the model. It shouldn't usually be necessary to use the manual functions unless you're doing something weird, like providing a custom queryset.","title":"Relationships"},{"location":"reference/pairs/#forward_relationship","text":"See qs.prefetch_forward_relationship","title":"pairs.forward_relationship(name, related_queryset, relationship_pair, to_attr=None)"},{"location":"reference/pairs/#reverse_relationship","text":"See qs.prefetch_reverse_relationship","title":"pairs.reverse_relationship(name, related_name, related_queryset, relationship_pair, to_attr=None)"},{"location":"reference/pairs/#many_to_many_relationship","text":"See qs.prefetch_many_to_many_relationship","title":"pairs.many_to_many_relationship(name, related_queryset, relationship_pair, to_attr=None)"},{"location":"reference/pairs/#relationship","text":"See qs.auto_prefetch_relationship","title":"pairs.relationship(name, relationship_pair, to_attr=None)"},{"location":"reference/pairs/#pk_list","text":"Given an attribute name (which should be a relationship field), return a pair consisting of a queryset function which prefetches the relationship (including only the primary key of each related object) and a producer which returns a list of those primary keys (or just a single PK if this is a to-one field, but this is an inefficient way of doing it). See producers.pk_list","title":"pairs.pk_list(name, to_attr=None)"},{"location":"reference/pairs/#utilities","text":"The following functions are useful when working with pairs in your codebase.","title":"Utilities"},{"location":"reference/pairs/#producer_to_projector","text":"Given a name (key) and a producer pair consisting of a queryset function and a producer function, returns a projector pair consisting of the same queryset function, and a projector function which returns a dictionary mapping the name to the value derived from the producer.","title":"pairs.producer_to_projector(name, pair)"},{"location":"reference/pairs/#combine","text":"Given a list of projector pairs as *args , return a pair which consists of a queryset function which pipes together the queryset function from each pair, and a projector which combines the projector function from each pair.","title":"pairs.combine(*pairs)"},{"location":"reference/pairs/#discard_projector","text":"Given a pair, return only the first item in the pair (the queryset function). This is equivalent to pairs[0] , but using the function can make the intention clearer.","title":"pairs.discard_projector(pair)"},{"location":"reference/pairs/#discard_queryset_function","text":"Given a pair, return only the second item in the pair (the projector function). This is equivalent to pairs[1] , but using the function can make the intention clearer.","title":"pairs.discard_queryset_function(pair)"},{"location":"reference/producers/","text":"Producer functions take a model instance as their single argument and return a value derived from that instance. The producers module contains higher-order functions that create producers. Import like this: from django_readers import producers producers.attr(name, *, transform_value=None, transform_value_if_none=False) \u00b6 Returns a producer which gets the specified attribute name from the instance. Most useful for retrieving the value of model fields. instance = Book ( title = \"Pro Django\" ) produce_title = producers . attr ( \"title\" ) value = produce_title ( instance ) print ( value ) # prints \"Pro Django\" The producers.attr function takes an optional argument transform_value , which is a function that receives the value of the attribute and returns a new value. This is useful if the value of the attribute needs to be converted in some way. For example, imagine you have an IntegerField but you want the produced value to be a stringified version of the integer value. In that case, you can use producers.attr(\"my_integer_field\", transform_value=str) . By default, the transform_value function is only called if the value of the attribute is not None (so in the example above, if the database value of my_integer_field is NULL then None would be returned, rather than the string \"None\" ). If you want the transform_value function to always be called, use producers.attr(\"my_integer_field\", transform_value=str, transform_value_if_none=True) . producers.method(name, /, *args, **kwargs) \u00b6 Returns a producer that calls the method name on the instance. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example: class Book ( models . Model ): ... def published_in_year ( self , year ): return self . publication_date . year == year instance = Book ( publication_year = 2020 ) produce_published_in_2020 = producers . method ( \"published_in_year\" , 2020 ) value = produce_published_in_2020 ( instance ) print ( value ) # prints \"True\" producers.relationship(name, related_projector) \u00b6 Note You shouldn't generally need to use this function directly, instead it would be called for you via a higher-level construct such as a pair function or a spec . Given an attribute name and a projector , return a producer which plucks the attribute off the instance, figures out whether it represents a single object or an iterable/queryset of objects, and applies the given projector to the related object or objects. producers.pk_list(name) \u00b6 Note You shouldn't generally need to use this function directly, instead it would be called for you via a higher-level pair function . Given an attribute name (which should be a relationship field), return a producer which returns a flat list of the primary key of each item in the relationship (or just a single PK if this is a to-one field, but this is usually an inefficient way of doing it).","title":"Producers"},{"location":"reference/producers/#attr","text":"Returns a producer which gets the specified attribute name from the instance. Most useful for retrieving the value of model fields. instance = Book ( title = \"Pro Django\" ) produce_title = producers . attr ( \"title\" ) value = produce_title ( instance ) print ( value ) # prints \"Pro Django\" The producers.attr function takes an optional argument transform_value , which is a function that receives the value of the attribute and returns a new value. This is useful if the value of the attribute needs to be converted in some way. For example, imagine you have an IntegerField but you want the produced value to be a stringified version of the integer value. In that case, you can use producers.attr(\"my_integer_field\", transform_value=str) . By default, the transform_value function is only called if the value of the attribute is not None (so in the example above, if the database value of my_integer_field is NULL then None would be returned, rather than the string \"None\" ). If you want the transform_value function to always be called, use producers.attr(\"my_integer_field\", transform_value=str, transform_value_if_none=True) .","title":"producers.attr(name, *, transform_value=None, transform_value_if_none=False)"},{"location":"reference/producers/#method","text":"Returns a producer that calls the method name on the instance. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example: class Book ( models . Model ): ... def published_in_year ( self , year ): return self . publication_date . year == year instance = Book ( publication_year = 2020 ) produce_published_in_2020 = producers . method ( \"published_in_year\" , 2020 ) value = produce_published_in_2020 ( instance ) print ( value ) # prints \"True\"","title":"producers.method(name, /, *args, **kwargs)"},{"location":"reference/producers/#relationship","text":"Note You shouldn't generally need to use this function directly, instead it would be called for you via a higher-level construct such as a pair function or a spec . Given an attribute name and a projector , return a producer which plucks the attribute off the instance, figures out whether it represents a single object or an iterable/queryset of objects, and applies the given projector to the related object or objects.","title":"producers.relationship(name, related_projector)"},{"location":"reference/producers/#pk_list","text":"Note You shouldn't generally need to use this function directly, instead it would be called for you via a higher-level pair function . Given an attribute name (which should be a relationship field), return a producer which returns a flat list of the primary key of each item in the relationship (or just a single PK if this is a to-one field, but this is usually an inefficient way of doing it).","title":"producers.pk_list(name)"},{"location":"reference/projectors/","text":"Projector functions take a model instance as their single argument and return a dictionary mapping one or more keys to one or more values derived from that instance, usually via producer functions . The projectors module contains higher-order functions that create projectors from producers, and compose projectors together. Import like this: from django_readers import projectors projectors.producer_to_projector(key, producer) \u00b6 Given a key and a producer function, return a projector which calls the producer function on the given instance and returns a dictionary containing a single key mapping to this value. instance = Book ( title = \"Pro Django\" ) produce_title = producers . attr ( \"title\" ) project = projectors . producer_to_projector ( \"title\" , produce_title ) projection = project ( instance ) print ( projection ) # prints {\"title\": \"Pro Django\"} projectors.combine(*projectors) \u00b6 Takes multiple projectors provided as arguments and return another projector which calls each projector in turn and merges the resulting dictionaries. instance = Book ( title = \"Pro Django\" , publication_date = datetime . date ( 2013 , 7 , 10 ), ) produce_title = producers . attr ( \"title\" ) produce_pub_date : producers . attr ( \"publication_date\" ) project = projectors . combine ( projectors . producer_to_projector ( \"title\" , produce_title ), projectors . producer_to_projector ( \"publication_date\" , produce_pub_date ), ) projection = project ( instance ) print ( projection ) # prints {\"title\": \"Pro Django\", \"publication_date\": datetime.date(2013, 7, 10)} projectors.noop \u00b6 A projector function which just returns an empty dictionary. Useful for including pairs in a spec which affect only the queryset, not the projection.","title":"Projectors"},{"location":"reference/projectors/#producer_to_projector","text":"Given a key and a producer function, return a projector which calls the producer function on the given instance and returns a dictionary containing a single key mapping to this value. instance = Book ( title = \"Pro Django\" ) produce_title = producers . attr ( \"title\" ) project = projectors . producer_to_projector ( \"title\" , produce_title ) projection = project ( instance ) print ( projection ) # prints {\"title\": \"Pro Django\"}","title":"projectors.producer_to_projector(key, producer)"},{"location":"reference/projectors/#combine","text":"Takes multiple projectors provided as arguments and return another projector which calls each projector in turn and merges the resulting dictionaries. instance = Book ( title = \"Pro Django\" , publication_date = datetime . date ( 2013 , 7 , 10 ), ) produce_title = producers . attr ( \"title\" ) produce_pub_date : producers . attr ( \"publication_date\" ) project = projectors . combine ( projectors . producer_to_projector ( \"title\" , produce_title ), projectors . producer_to_projector ( \"publication_date\" , produce_pub_date ), ) projection = project ( instance ) print ( projection ) # prints {\"title\": \"Pro Django\", \"publication_date\": datetime.date(2013, 7, 10)}","title":"projectors.combine(*projectors)"},{"location":"reference/projectors/#noop","text":"A projector function which just returns an empty dictionary. Useful for including pairs in a spec which affect only the queryset, not the projection.","title":"projectors.noop"},{"location":"reference/queryset-functions/","text":"Queryset functions take a queryset as their single argument and return a modified queryset. The qs module contains higher-order functions that create queryset functions. Import like this: from django_readers import qs Functions that mirror built-in QuerySet methods \u00b6 qs.filter qs.all qs.exclude qs.select_related qs.prefetch_related qs.order_by qs.distinct qs.extra qs.defer qs.only qs.using qs.annotate qs.alias These functions mirror the methods on the base QuerySet class that return new querysets. See the Django documentation for an explanation of these. An example of how to use them: prepare = qs . filter ( name__startswith = \"Fred\" ) queryset = prepare ( Author . objects . all ()) This is equivalent to: queryset = Author . objects . filter ( name__startswith = \"Fred\" ) qs.noop \u00b6 This is a queryset function that does nothing: equivalent to calling .all() on a queryset. It is useful for creating pairs in which the producer function does not require any data from the database to return its value. qs.include_fields(*fields) \u00b6 Returns a queryset function that tells the queryset to return the specified fields from the database and defer the rest. This is like the built-in .only(*fields) method, but is composable . On a standard queryset, repeated calls to .only will override each other, so calling Author.objects.only(\"name\").only(\"email\") is equivalent to just calling Author.objects.only(\"email\") . On the other hand, include_fields adds the provided fields to the set of fields to load: queryset = Author . objects . all () queryset = qs . include_fields ( \"name\" )( queryset ) queryset = qs . include_fields ( \"email\" )( queryset ) This is equivalent to Author.objects.only(\"name\", \"email\") . qs.pipe(*fns) \u00b6 Queryset functions can be composed with the pipe function (named following standard functional programming parlance). qs.pipe returns a new queryset function that calls each function in its argument list in turn, passing the return value of the first as the argument of the second, and so on. It literally \"pipes\" your queryset through its list of functions. prepare = qs . pipe ( qs . include_fields ( \"name\" ), qs . include_fields ( \"email\" ), qs . filter ( name__startswith = \"Fred\" ), ) queryset = prepare ( Author . objects . all ()) Think of pipe as being a nicer way to nest queryset function calls: queryset = qs . filter ( name__startswith = \"Fred\" )( qs . include_fields ( \"email\" )( qs . include_fields ( \"name\" )( Author . objects . all (), ) ) ) qs.select_related_fields(*fields) \u00b6 Combines select_related with include_fields to allow you to specify exactly which fields you need from the related objects. prepare = qs . pipe ( qs . include_fields ( \"title\" ), qs . select_related_fields ( \"publisher__name\" ), ) Prefetching \u00b6 Note The below functions return functions that use prefetch_related to efficiently load related objects. We use prefetch_related to load all relationship types because this means our functions can be recursive: we can apply pairs to the related querysets, all the way down the tree. There are six types of relationship from the point of view of the \"main\" object: Forward one-to-one - a OneToOneField on the main object Reverse one-to-one - a OneToOneField on the related object Forward many-to-one - a ForeignKey on the main object Reverse many-to-one - a ForeignKey on the related object Forward many-to-many - a ManyToManyField on the main object Reverse many-to-many - a ManyToManyField on the related object ManyToManyFields are symmetrical, so the latter two collapse down to the same thing. The forward one-to-one and many-to-one are identical as they both relate a single related object to the main object. The reverse one-to-one and many-to-one are identical except the former relates the main object to a single related object, and the latter relates the main object to many related objects. Because the projectors.relationship function already infers whether to iterate or project a single instance, we can collapse these two functions into one as well. There are functions for forward, reverse or many-to-many relationships, and then an \"auto\" function which selects the correct relationship type by introspecting the model. It shouldn't usually be necessary to use the manual functions unless you're doing something weird, like providing a custom queryset. qs.prefetch_forward_relationship(name, related_queryset, prepare_related_queryset=noop, to_attr=None) \u00b6 Note It shouldn't usually be necessary to use this function directly: auto_prefetch_relationship (see below) is almost always a better option. prepare = qs . prefetch_forward_relationship ( \"publisher\" , Publisher . objects . all (), qs . include_fields ( \"name\" ), ) queryset = prepare ( Book . objects . all ()) This is equivalent to: queryset = Book . objects . prefetch_related ( Prefetch ( \"publisher\" , queryset = Publisher . objects . only ( \"name\" )) ) prefetch_reverse_relationship(name, related_name, related_queryset, prepare_related_queryset=noop, to_attr=None) \u00b6 Note It shouldn't usually be necessary to use this function directly: auto_prefetch_relationship (see below) is almost always a better option. prepare = qs . prefetch_reverse_relationship ( \"book_set\" , \"publisher\" , Book . objects . all (), qs . include_fields ( \"name\" ), ) queryset = prepare ( Publisher . objects . all ()) This is equivalent to: queryset = Publisher . objects . prefetch_related ( Prefetch ( \"book_set\" , queryset = Book . objects . only ( \"publisher\" , \"name\" )) ) prefetch_many_to_many_relationship(name, related_queryset, prepare_related_queryset=noop, to_attr=None) \u00b6 Note It shouldn't usually be necessary to use this function directly: auto_prefetch_relationship (see below) is almost always a better option. prepare = qs . prefetch_many_to_many_relationship ( \"authors\" , Author . objects . all (), qs . include_fields ( \"name\" ), ) This is equivalent to: queryset = Book . objects . prefetch_related ( Prefetch ( \"authors\" , queryset = Author . objects . only ( \"name\" )) ) qs.auto_prefetch_relationship(name, prepare_related_queryset=noop, to_attr=None) \u00b6 Usually, the above functions do not need to be used directly. Instead, auto_prefetch_relationship can figure out which one to use by looking at the model: prepare = qs . pipe ( qs . auto_prefetch_relationship ( \"authors\" , prepare_related_queryset = qs . pipe ( qs . include_fields ( \"name\" ), qs . filter ( email__icontains = \"google.com\" ), to_attr = \"googley_authors\" , ), ), qs . auto_prefetch_relationship ( \"publisher\" , prepare_related_queryset = qs . include_fields ( \"name\" ) ), ) queryset = prepare ( Book . objects . all ())","title":"Queryset functions"},{"location":"reference/queryset-functions/#functions-that-mirror-built-in-queryset-methods","text":"qs.filter qs.all qs.exclude qs.select_related qs.prefetch_related qs.order_by qs.distinct qs.extra qs.defer qs.only qs.using qs.annotate qs.alias These functions mirror the methods on the base QuerySet class that return new querysets. See the Django documentation for an explanation of these. An example of how to use them: prepare = qs . filter ( name__startswith = \"Fred\" ) queryset = prepare ( Author . objects . all ()) This is equivalent to: queryset = Author . objects . filter ( name__startswith = \"Fred\" )","title":"Functions that mirror built-in QuerySet methods"},{"location":"reference/queryset-functions/#noop","text":"This is a queryset function that does nothing: equivalent to calling .all() on a queryset. It is useful for creating pairs in which the producer function does not require any data from the database to return its value.","title":"qs.noop"},{"location":"reference/queryset-functions/#include_fields","text":"Returns a queryset function that tells the queryset to return the specified fields from the database and defer the rest. This is like the built-in .only(*fields) method, but is composable . On a standard queryset, repeated calls to .only will override each other, so calling Author.objects.only(\"name\").only(\"email\") is equivalent to just calling Author.objects.only(\"email\") . On the other hand, include_fields adds the provided fields to the set of fields to load: queryset = Author . objects . all () queryset = qs . include_fields ( \"name\" )( queryset ) queryset = qs . include_fields ( \"email\" )( queryset ) This is equivalent to Author.objects.only(\"name\", \"email\") .","title":"qs.include_fields(*fields)"},{"location":"reference/queryset-functions/#pipe","text":"Queryset functions can be composed with the pipe function (named following standard functional programming parlance). qs.pipe returns a new queryset function that calls each function in its argument list in turn, passing the return value of the first as the argument of the second, and so on. It literally \"pipes\" your queryset through its list of functions. prepare = qs . pipe ( qs . include_fields ( \"name\" ), qs . include_fields ( \"email\" ), qs . filter ( name__startswith = \"Fred\" ), ) queryset = prepare ( Author . objects . all ()) Think of pipe as being a nicer way to nest queryset function calls: queryset = qs . filter ( name__startswith = \"Fred\" )( qs . include_fields ( \"email\" )( qs . include_fields ( \"name\" )( Author . objects . all (), ) ) )","title":"qs.pipe(*fns)"},{"location":"reference/queryset-functions/#select_related_fields","text":"Combines select_related with include_fields to allow you to specify exactly which fields you need from the related objects. prepare = qs . pipe ( qs . include_fields ( \"title\" ), qs . select_related_fields ( \"publisher__name\" ), )","title":"qs.select_related_fields(*fields)"},{"location":"reference/queryset-functions/#prefetching","text":"Note The below functions return functions that use prefetch_related to efficiently load related objects. We use prefetch_related to load all relationship types because this means our functions can be recursive: we can apply pairs to the related querysets, all the way down the tree. There are six types of relationship from the point of view of the \"main\" object: Forward one-to-one - a OneToOneField on the main object Reverse one-to-one - a OneToOneField on the related object Forward many-to-one - a ForeignKey on the main object Reverse many-to-one - a ForeignKey on the related object Forward many-to-many - a ManyToManyField on the main object Reverse many-to-many - a ManyToManyField on the related object ManyToManyFields are symmetrical, so the latter two collapse down to the same thing. The forward one-to-one and many-to-one are identical as they both relate a single related object to the main object. The reverse one-to-one and many-to-one are identical except the former relates the main object to a single related object, and the latter relates the main object to many related objects. Because the projectors.relationship function already infers whether to iterate or project a single instance, we can collapse these two functions into one as well. There are functions for forward, reverse or many-to-many relationships, and then an \"auto\" function which selects the correct relationship type by introspecting the model. It shouldn't usually be necessary to use the manual functions unless you're doing something weird, like providing a custom queryset.","title":"Prefetching"},{"location":"reference/queryset-functions/#prefetch_forward_relationship","text":"Note It shouldn't usually be necessary to use this function directly: auto_prefetch_relationship (see below) is almost always a better option. prepare = qs . prefetch_forward_relationship ( \"publisher\" , Publisher . objects . all (), qs . include_fields ( \"name\" ), ) queryset = prepare ( Book . objects . all ()) This is equivalent to: queryset = Book . objects . prefetch_related ( Prefetch ( \"publisher\" , queryset = Publisher . objects . only ( \"name\" )) )","title":"qs.prefetch_forward_relationship(name, related_queryset, prepare_related_queryset=noop, to_attr=None)"},{"location":"reference/queryset-functions/#prefetch_reverse_relationship","text":"Note It shouldn't usually be necessary to use this function directly: auto_prefetch_relationship (see below) is almost always a better option. prepare = qs . prefetch_reverse_relationship ( \"book_set\" , \"publisher\" , Book . objects . all (), qs . include_fields ( \"name\" ), ) queryset = prepare ( Publisher . objects . all ()) This is equivalent to: queryset = Publisher . objects . prefetch_related ( Prefetch ( \"book_set\" , queryset = Book . objects . only ( \"publisher\" , \"name\" )) )","title":"prefetch_reverse_relationship(name, related_name, related_queryset, prepare_related_queryset=noop, to_attr=None)"},{"location":"reference/queryset-functions/#prefetch_many_to_many_relationship","text":"Note It shouldn't usually be necessary to use this function directly: auto_prefetch_relationship (see below) is almost always a better option. prepare = qs . prefetch_many_to_many_relationship ( \"authors\" , Author . objects . all (), qs . include_fields ( \"name\" ), ) This is equivalent to: queryset = Book . objects . prefetch_related ( Prefetch ( \"authors\" , queryset = Author . objects . only ( \"name\" )) )","title":"prefetch_many_to_many_relationship(name, related_queryset, prepare_related_queryset=noop, to_attr=None)"},{"location":"reference/queryset-functions/#auto_prefetch_relationship","text":"Usually, the above functions do not need to be used directly. Instead, auto_prefetch_relationship can figure out which one to use by looking at the model: prepare = qs . pipe ( qs . auto_prefetch_relationship ( \"authors\" , prepare_related_queryset = qs . pipe ( qs . include_fields ( \"name\" ), qs . filter ( email__icontains = \"google.com\" ), to_attr = \"googley_authors\" , ), ), qs . auto_prefetch_relationship ( \"publisher\" , prepare_related_queryset = qs . include_fields ( \"name\" ) ), ) queryset = prepare ( Book . objects . all ())","title":"qs.auto_prefetch_relationship(name, prepare_related_queryset=noop, to_attr=None)"},{"location":"reference/rest-framework/","text":"If you use django-rest-framework , django-readers provides a view mixin that allows you to easily use a spec to serialize your data: from django_readers.rest_framework import SpecMixin class AuthorDetailView ( SpecMixin , RetrieveAPIView ): queryset = Author . objects . all () spec = [ \"id\" , \"name\" , { \"book_set\" : [ \"id\" , \"title\" , \"publication_date\" , ] }, ] This mixin is only suitable for use with RetrieveAPIView or ListAPIView . It doesn't use a \"real\" Serializer: it calls the project function that is the result of processing your spec . We recommend using separate views for endpoints that modify data, rather than combining these concerns into a single endpoint. If your endpoint needs to provide dynamic behaviour based on the incoming request, you have two options: SpecMixin supports one extra feature in its spec property: any callable in the spec (in place of a pair) will automatically be called at request time, and passed a single argument: the request object. This callable can return a pair of functions that close over the request. You can override the get_spec method and return your spec. Note that this approach is not compatible with schema generation (see below). If you need to override get_queryset , you must call self.prepare on the queryset that you return: class GoogleyAuthorListView ( SpecMixin , ListAPIView ): spec = [ ... , ] def get_queryset ( self ): queryset = Author . objects . filter ( email__contains = \"google.com\" ) return self . prepare ( queryset ) Serializer and schema generation \u00b6 The django-readers SpecMixin bypasses the usual Django REST framework approach of serializing data using a Serializer in favour of using a projector function to generate a mapping of names to values based on a model instance. This is simpler, faster and less memory intensive than using a Serializer . However, some parts of REST framework rely on serializers to do their work; in particular, the schema generation mechanism introspects serializer fields to generate an OpenAPI schema. To enable schema generation (and any other requirements for a \"real\" serializer) for django-readers views, two utility functions are provided: serializer_class_for_spec and serializer_class_for_view . Note that the serializers created by these functions are not actually used at request time: they are useful only for introspection. rest_framework.serializer_class_for_spec(name_prefix, model, spec) \u00b6 This takes: A name prefix for the resulting top-level serializer class. This should be CapitalizedWords , the word Serializer will be appended. A model class A spec It returns a serializer class representing the spec, with nested serializers representing the relationships. For named fields (strings in the spec) it uses the same mechanism as ModelSerializer to introspect the model and select appropriate serializer fields for each model field. For custom pairs, the field must be specified explicitly: see below for details. spec = [ \"name\" , { \"book_set\" : [ \"id\" , \"title\" , ] }, ] cls = serializer_class_for_spec ( \"Publisher\" , Publisher , spec ) print ( cls ()) This prints something like: PublisherSerializer(): name = CharField(max_length=100, read_only=True) book_set = PublisherBookSetSerializer(many=True, read_only=True): id = IntegerField(label='ID', read_only=True) title = CharField(allow_null=True, max_length=100, read_only=True, required=False) rest_framework.serializer_class_for_view(view) \u00b6 This higher-level function generates a serializer given a view instance. The name of the serializer is inferred from the view name (the word View is removed). The model class is taken from either the queryset attribute of the view, or (if get_queryset has been overridden), explicitly from the model attribute. The spec is taken from the spec attribute of the view. This can be used to create a simple custom AutoSchema subclass to support schema generation: class SpecSchema ( AutoSchema ): def get_serializer ( self , path , method ): return serializer_class_for_view ( self . view )() Note that django-readers does not provide this view mixin: it is trivial to create and add to your project, and it is likely that it will need to be customised to your specific needs. Customising serializer fields \u00b6 For named fields (strings) in a spec, serializer_class_for_spec uses the same mechanism as ModelSerializer to infer the field types for the model. However, for custom pairs in a spec, the serializer field to use must be specified explicitly. django-readers provides a utility called out which can be used in two ways: as a decorator, or inline in a spec. out as a decorator \u00b6 For custom pair functions, you can use out as a decorator, and provide a serializer field instance to use in the serializer: from django_readers.rest_framework import out @out ( serializers . CharField ()) def hello_world (): return qs . noop , lambda instance : \"Hello world\" class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"hello\" : hello_world ()}, ... , ] You can also decorate only the producer function of a pair: @out ( serializers . CharField ()) def produce_hello_world ( instance ): return \"Hello world\" hello_world = qs . noop , produce_hello_world class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"hello\" : hello_world }, ... , ] For projector pairs, out should be given a dictionary mapping the field names in the returned dictionary to their output field types: @out ( { \"hello\" : serializers . CharField (), \"answer\" : serializers . IntegerField (), } ) def hello_world (): return qs . noop , lambda instance : { \"hello\" : \"world\" , \"answer\" : 42 } class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , hello_world (), ... , ] Again, you can also decorate only the projector function of the pair. out used inline in a spec \u00b6 For cases where a reusable pair function (eg from the django_readers.pairs module) is being used in a spec, it may be inconvenient to wrap this in a function just to apply the out decorator. In this case, out supports a special \" DSL -ish\" syntax, by overriding the >> operator to allow it to easily be used inline in a spec: class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"genre\" : pairs . field_display ( \"genre\" ) >> out ( serializers . CharField ())}, ... , ] This mechanism can also be used to override the output field type for an autogenerated field (a string). Overriding default behaviour \u00b6 Rather than providing a serializer field instance to out , you can optionally provide keyword arguments that will be used when constructing the default serializer field that would otherwise be generated by model field introspection. This is particularly useful when using the generated serializers to create a schema, because schema generation libraries often use label and help_text to add metadata to fields in the schema. For example: class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , \"title\" >> out ( label = \"The title of the object\" ) ... , ] Using Python type annotations \u00b6 In simple cases, it's also possible to infer serializer field types from Python types. You can use a type object as an argument to out in place of a field: @out ( str ) def produce_hello_world ( instance ): return \"Hello world\" This works inline in a spec too: class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"genre\" : pairs . field_display ( \"genre\" ) >> out ( str )}, ... , ] Or you can use a Python type hint on the producer function: def produce_hello_world ( instance ) -> str : return \"Hello world\" The table below shows which types are supported, and the resulting serializer field type. In all cases, adding | None or Optional will result in the allow_null=True argument being passed to the generated serializer field. Type Serializer Field int IntegerField str CharField float FloatField bool BooleanField date DateField datetime DateTimeField time TimeField timedelta DurationField","title":"REST framework"},{"location":"reference/rest-framework/#serializer-and-schema-generation","text":"The django-readers SpecMixin bypasses the usual Django REST framework approach of serializing data using a Serializer in favour of using a projector function to generate a mapping of names to values based on a model instance. This is simpler, faster and less memory intensive than using a Serializer . However, some parts of REST framework rely on serializers to do their work; in particular, the schema generation mechanism introspects serializer fields to generate an OpenAPI schema. To enable schema generation (and any other requirements for a \"real\" serializer) for django-readers views, two utility functions are provided: serializer_class_for_spec and serializer_class_for_view . Note that the serializers created by these functions are not actually used at request time: they are useful only for introspection.","title":"Serializer and schema generation"},{"location":"reference/rest-framework/#serializer-class-for-spec","text":"This takes: A name prefix for the resulting top-level serializer class. This should be CapitalizedWords , the word Serializer will be appended. A model class A spec It returns a serializer class representing the spec, with nested serializers representing the relationships. For named fields (strings in the spec) it uses the same mechanism as ModelSerializer to introspect the model and select appropriate serializer fields for each model field. For custom pairs, the field must be specified explicitly: see below for details. spec = [ \"name\" , { \"book_set\" : [ \"id\" , \"title\" , ] }, ] cls = serializer_class_for_spec ( \"Publisher\" , Publisher , spec ) print ( cls ()) This prints something like: PublisherSerializer(): name = CharField(max_length=100, read_only=True) book_set = PublisherBookSetSerializer(many=True, read_only=True): id = IntegerField(label='ID', read_only=True) title = CharField(allow_null=True, max_length=100, read_only=True, required=False)","title":"rest_framework.serializer_class_for_spec(name_prefix, model, spec)"},{"location":"reference/rest-framework/#serializer-class-for-view","text":"This higher-level function generates a serializer given a view instance. The name of the serializer is inferred from the view name (the word View is removed). The model class is taken from either the queryset attribute of the view, or (if get_queryset has been overridden), explicitly from the model attribute. The spec is taken from the spec attribute of the view. This can be used to create a simple custom AutoSchema subclass to support schema generation: class SpecSchema ( AutoSchema ): def get_serializer ( self , path , method ): return serializer_class_for_view ( self . view )() Note that django-readers does not provide this view mixin: it is trivial to create and add to your project, and it is likely that it will need to be customised to your specific needs.","title":"rest_framework.serializer_class_for_view(view)"},{"location":"reference/rest-framework/#customising-serializer-fields","text":"For named fields (strings) in a spec, serializer_class_for_spec uses the same mechanism as ModelSerializer to infer the field types for the model. However, for custom pairs in a spec, the serializer field to use must be specified explicitly. django-readers provides a utility called out which can be used in two ways: as a decorator, or inline in a spec.","title":"Customising serializer fields"},{"location":"reference/rest-framework/#out-as-a-decorator","text":"For custom pair functions, you can use out as a decorator, and provide a serializer field instance to use in the serializer: from django_readers.rest_framework import out @out ( serializers . CharField ()) def hello_world (): return qs . noop , lambda instance : \"Hello world\" class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"hello\" : hello_world ()}, ... , ] You can also decorate only the producer function of a pair: @out ( serializers . CharField ()) def produce_hello_world ( instance ): return \"Hello world\" hello_world = qs . noop , produce_hello_world class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"hello\" : hello_world }, ... , ] For projector pairs, out should be given a dictionary mapping the field names in the returned dictionary to their output field types: @out ( { \"hello\" : serializers . CharField (), \"answer\" : serializers . IntegerField (), } ) def hello_world (): return qs . noop , lambda instance : { \"hello\" : \"world\" , \"answer\" : 42 } class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , hello_world (), ... , ] Again, you can also decorate only the projector function of the pair.","title":"out as a decorator"},{"location":"reference/rest-framework/#out-used-inline-in-a-spec","text":"For cases where a reusable pair function (eg from the django_readers.pairs module) is being used in a spec, it may be inconvenient to wrap this in a function just to apply the out decorator. In this case, out supports a special \" DSL -ish\" syntax, by overriding the >> operator to allow it to easily be used inline in a spec: class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"genre\" : pairs . field_display ( \"genre\" ) >> out ( serializers . CharField ())}, ... , ] This mechanism can also be used to override the output field type for an autogenerated field (a string).","title":"out used inline in a spec"},{"location":"reference/rest-framework/#overriding-default-behaviour","text":"Rather than providing a serializer field instance to out , you can optionally provide keyword arguments that will be used when constructing the default serializer field that would otherwise be generated by model field introspection. This is particularly useful when using the generated serializers to create a schema, because schema generation libraries often use label and help_text to add metadata to fields in the schema. For example: class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , \"title\" >> out ( label = \"The title of the object\" ) ... , ]","title":"Overriding default behaviour"},{"location":"reference/rest-framework/#using-python-type-annotations","text":"In simple cases, it's also possible to infer serializer field types from Python types. You can use a type object as an argument to out in place of a field: @out ( str ) def produce_hello_world ( instance ): return \"Hello world\" This works inline in a spec too: class SomeView ( SpecMixin , RetrieveAPIView ): queryset = SomeModel . objects . all () spec = [ ... , { \"genre\" : pairs . field_display ( \"genre\" ) >> out ( str )}, ... , ] Or you can use a Python type hint on the producer function: def produce_hello_world ( instance ) -> str : return \"Hello world\" The table below shows which types are supported, and the resulting serializer field type. In all cases, adding | None or Optional will result in the allow_null=True argument being passed to the generated serializer field. Type Serializer Field int IntegerField str CharField float FloatField bool BooleanField date DateField datetime DateTimeField time TimeField timedelta DurationField","title":"Using Python type annotations"},{"location":"reference/specs/","text":"The specs module provides a layer of syntactic sugar on top of pairs that makes it much quicker and easier to assemble complex trees of producers and projectors. This layer is the real magic of django-readers : a straightforward way of specifying the shape of your data in order to efficiently select and project a complex tree of related objects. A spec is a list. Under the hood, the specs module is a very lightweight wrapper on top of pairs . Simple transformations are applied to each item in the spec to replace it with the relevant pair function. The list may contain: Strings . These are interpreted as field names and are replaced with pairs.field . Dictionaries serve two purposes: If the dictionary value is a list, they are interpreted as relationships, with the key specifying the relationship name and the value being a \"child spec\" for projecting the related objects. This is a shortcut for pairs.relationship . If the value is anything else (a string or a (prepare, produce) pair), the value returned by the produce function in the pair is projected under the specified key. This is a shortcut for pairs.producer_to_projector . Projector pairs of (prepare, project) functions. These are left as-is, allowing you to implement your own arbitrarily complex logic if needed. Import like this: from django_readers import specs specs.process(spec) \u00b6 Takes a spec and returns a projector pair (prepare, project) . from django_readers import specs spec = [ \"name\" , { \"book_set\" : [ \"title\" , \"publication_date\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Author . objects . all ()) result = [ project ( instance ) for instance in queryset ] Note if django-zen-queries is installed (which is recommended!), django-readers will automatically apply queries_disabled() to the prepare and project functions returned by specs.process . See the tutorial for details. specs.relationship(name, relationship_spec, to_attr=None) \u00b6 This function implements the behaviour of the {\"relationship_name\": [child spec..]} functionality in specs.process . It is useful if you wish to pass a to_attr argument to the underlying prefetch: spec = [ \"name\" , specs . relationship ( \"book_set\" , [ pairs . filter ( publication_date__year__lte = 2017 ), \"title\" , \"publication_date\" , ], to_attr = \"vintage_books\" , ), ]","title":"Specs"},{"location":"reference/specs/#process","text":"Takes a spec and returns a projector pair (prepare, project) . from django_readers import specs spec = [ \"name\" , { \"book_set\" : [ \"title\" , \"publication_date\" , ] }, ] prepare , project = specs . process ( spec ) queryset = prepare ( Author . objects . all ()) result = [ project ( instance ) for instance in queryset ] Note if django-zen-queries is installed (which is recommended!), django-readers will automatically apply queries_disabled() to the prepare and project functions returned by specs.process . See the tutorial for details.","title":"specs.process(spec)"},{"location":"reference/specs/#relationship","text":"This function implements the behaviour of the {\"relationship_name\": [child spec..]} functionality in specs.process . It is useful if you wish to pass a to_attr argument to the underlying prefetch: spec = [ \"name\" , specs . relationship ( \"book_set\" , [ pairs . filter ( publication_date__year__lte = 2017 ), \"title\" , \"publication_date\" , ], to_attr = \"vintage_books\" , ), ]","title":"specs.relationship(name, relationship_spec, to_attr=None)"}]}